<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class=" js flexbox canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths" style="" lang="zh-CN"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>image — 机器视觉 — MicroPython 1.9.2 文档</title>
  

  
  
    <link rel="shortcut icon" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/_static/favicon.ico">
  
  
  

  
  <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/modernizr.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="OpenMV%E8%B5%84%E6%96%99_files/documentation_options.js"></script>
        <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/jquery.js"></script>
        <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/underscore.js"></script>
        <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/doctools.js"></script>
        <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/language_data.js"></script>
        <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/translations.js"></script>
    
    <script type="text/javascript" src="OpenMV%E8%B5%84%E6%96%99_files/theme.js"></script>

    

  
  <link rel="stylesheet" href="OpenMV%E8%B5%84%E6%96%99_files/theme.css" type="text/css">
  <link rel="stylesheet" href="OpenMV%E8%B5%84%E6%96%99_files/pygments.css" type="text/css">
  <link rel="stylesheet" href="OpenMV%E8%B5%84%E6%96%99_files/customstyle.css" type="text/css">
    <link rel="index" title="索引" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/genindex.html">
    <link rel="search" title="搜索" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/search.html">
    <link rel="next" title="nn — 神经网络" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.nn.html">
    <link rel="prev" title="sensor — 感光元件" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html"> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html" class="icon icon-home"> MicroPython
          

          
            
            <img src="OpenMV%E8%B5%84%E6%96%99_files/web-logo-sticky-singtown.png" class="logo" alt="Logo">
          
          </a>

          
            
            
              <div class="version">
                1.9.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs">
    <input type="hidden" name="check_keywords" value="yes">
    <input type="hidden" name="area" value="default">
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/openmvcam/quickref.html">OpenMV Cam快速参考</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/openmvcam/general.html">OpenMV Cam基本信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/openmvcam/tutorial/index.html">OpenMV Cam 教程</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html"><span class="toctree-expand"></span>MicroPython 函数库</a><ul class="">
<li class="toctree-l2"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html#pythonmicro-libraries">Python标准库和micro-libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html#id2">MicroPython特定的库</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html#openmv-cam"><span class="toctree-expand"></span>特定于OpenMV Cam的库</a><ul class="">
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.html"><code class="docutils literal notranslate"><span class="pre">pyb</span></code> — 板级功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.ADC.html">ADC类 – 模数转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.CAN.html">CAN类 –控制器区域网络通信总线</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.DAC.html">DAC类 – 数字模拟变换</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.ExtInt.html">ExtInt类 – 配置I/O引脚以中断外部事件</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.I2C.html">I2C类 – 二线串行协议</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.LED.html">LED类 – LED对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Pin.html">Pin类 – 控制I/O 引脚</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Pin.html#class-pinaf">class PinAF – 引脚替代函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.RTC.html">class RTC – 实时时钟</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Servo.html">Servo类 –三线hobby舵机驱动</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.SPI.html">SPI类 – 串行外设接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Timer.html">Timer类 – 控制内部定时器</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Timer.html#timerchannel">TimerChannel类 — 为定时器建立一个通道</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.UART.html">UART类 – 双向串行通信总线</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.USB_VCP.html">USB_VCP 类– USB 虚拟通讯端口</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.time.html"><code class="docutils literal notranslate"><span class="pre">time</span></code> — 跟踪运行时间</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html"><code class="docutils literal notranslate"><span class="pre">sensor</span></code> — 感光元件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#"><span class="toctree-expand"></span><code class="docutils literal notranslate"><span class="pre">image</span></code> — 机器视觉</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#haarcascade"><span class="toctree-expand"></span>HaarCascade 类 – 特征描述符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">构造函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#similarity"><span class="toctree-expand"></span>Similarity 类 – 相似度对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#histogram"><span class="toctree-expand"></span>Histogram 类 – 直方图对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#percentile"><span class="toctree-expand"></span>Percentile 类 – 百分比值对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#threhsold"><span class="toctree-expand"></span>Threhsold 类 – 阈值对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#class-statistics"><span class="toctree-expand"></span>class Statistics – 统计数据对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#blob"><span class="toctree-expand"></span>Blob 类 – 色块对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#line"><span class="toctree-expand"></span>Line类 – 直线对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#circle"><span class="toctree-expand"></span>Circle类 –圆形对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rect"><span class="toctree-expand"></span>Rect类 – 矩形对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#qrcode"><span class="toctree-expand"></span>QRCode类 – 二维码对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id22">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#apriltag-apriltag"><span class="toctree-expand"></span>AprilTag类 – AprilTag对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datamatrix"><span class="toctree-expand"></span>DataMatrix类 – 数据矩阵对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id26">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#barcode"><span class="toctree-expand"></span>BarCode类 – 条形码对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id28">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#displacement"><span class="toctree-expand"></span>Displacement类 – 位移对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id30">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kptmatch"><span class="toctree-expand"></span>Kptmatch类 – 特征点对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id32">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imagewriter-imagewriter"><span class="toctree-expand"></span>ImageWriter类 – ImageWriter对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id34">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imagereader-imagereader"><span class="toctree-expand"></span>ImageReader 类– ImageReader对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id36">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id37">方法</a></li>
</ul>
</li>
<li class="toctree-l3 current"><a class="reference internal current" href="#id38"><span class="toctree-expand"></span>Image类 – 图像对象</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id39">构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id40">方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id51">常量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.nn.html"><code class="docutils literal notranslate"><span class="pre">nn</span></code> — 神经网络</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.nn.html#nn-class">nn_class 类 – 神经网络检测结果</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.nn.html#net">Net 类 – 神经网络</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.gif.html"><code class="docutils literal notranslate"><span class="pre">gif</span></code> — 录制gif动图</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.gif.html#id1">Gif类 – Gif录制器</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.mjpeg.html"><code class="docutils literal notranslate"><span class="pre">mjpeg</span></code> — mjpeg录制</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.mjpeg.html#id1">Mjpeg类 – Mjpeg录制</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.lcd.html"><code class="docutils literal notranslate"><span class="pre">lcd</span></code> — lcd扩展板驱动</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.fir.html"><code class="docutils literal notranslate"><span class="pre">fir</span></code> — 热成像扩展板驱动 (fir == 远红外线)</a></li>
<li class="toctree-l3"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.cpufreq.html"><code class="docutils literal notranslate"><span class="pre">cpufreq</span></code> —  简便cpu频率控制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html#id3">OpenMV Cam上的第三方库</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/reference/index.html">MicroPython语言</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/genrst/index.html">MicroPython 与 CPython 的不同</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/license.html">MicroPython 许可证信息</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">MicroPython</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/openmvcam_index.html">Docs</a> »</li>
        
          <li><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html">MicroPython 函数库</a> »</li>
        
      <li><code class="docutils literal notranslate"><span class="pre">image</span></code> — 机器视觉</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/_sources/library/omv.image.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="image">
<h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">image</span></code> — 机器视觉<a class="headerlink" href="#image" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt id="image.binary_to_grayscale">
<code class="descclassname">image.</code><code class="descname">binary_to_grayscale</code><span class="sig-paren">(</span><em>binary_image_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_grayscale" title="永久链接至目标">¶</a></dt>
<dd><p>返回二进制值(0-1)对应的灰度值(0-255)。</p>
</dd></dl>

<dl class="function">
<dt id="image.binary_to_rgb">
<code class="descclassname">image.</code><code class="descname">binary_to_rgb</code><span class="sig-paren">(</span><em>binary_image_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_rgb" title="永久链接至目标">¶</a></dt>
<dd><p>返回二进制值(0-1)对应的RGB888格式的元组(r, g, b)。</p>
</dd></dl>

<dl class="function">
<dt id="image.binary_to_lab">
<code class="descclassname">image.</code><code class="descname">binary_to_lab</code><span class="sig-paren">(</span><em>binary_image_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_lab" title="永久链接至目标">¶</a></dt>
<dd><p>返回二进制值(0-1)对应的LAB格式的元组(l, a, b)。</p>
<p>L的范围为0到100, A和B的范围为-128到128。</p>
</dd></dl>

<dl class="function">
<dt id="image.binary_to_yuv">
<code class="descclassname">image.</code><code class="descname">binary_to_yuv</code><span class="sig-paren">(</span><em>binary_image_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_yuv" title="永久链接至目标">¶</a></dt>
<dd><p>返回二进制值(0-1)对应的YUV格式的元组(y, u, v)。</p>
<p>Y的范围为0到255, U和V范围为-128到128。</p>
</dd></dl>

<dl class="function">
<dt id="image.grayscale_to_binary">
<code class="descclassname">image.</code><code class="descname">grayscale_to_binary</code><span class="sig-paren">(</span><em>grayscale_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_binary" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度值(0-255)对应的二进制值(0-1)。</p>
</dd></dl>

<dl class="function">
<dt id="image.grayscale_to_rgb">
<code class="descclassname">image.</code><code class="descname">grayscale_to_rgb</code><span class="sig-paren">(</span><em>grayscale_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_rgb" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度值(0-255)对应的RGB888格式的元组(r, g, b)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB565-&gt;RGB888进程进行转换，因此此方法不会像纯RGB888系统那样返回准确的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.grayscale_to_lab">
<code class="descclassname">image.</code><code class="descname">grayscale_to_lab</code><span class="sig-paren">(</span><em>grayscale_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_lab" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度值(0-255)对应的LAB格式的元组(l, a, b)。</p>
<p>L的范围为0到100, A和B的范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB565-&gt;LAB进程进行转换，因此此方法不会像纯LAB系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.grayscale_to_yuv">
<code class="descclassname">image.</code><code class="descname">grayscale_to_yuv</code><span class="sig-paren">(</span><em>grayscale_value</em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_yuv" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度值(0-255)对应的YUV格式的元组(y, u, v)。</p>
<p>Y的范围为0到255, U和V范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB565-&gt;YUV进程进行转换，因此此方法不会像纯YUV系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.rgb_to_binary">
<code class="descclassname">image.</code><code class="descname">rgb_to_binary</code><span class="sig-paren">(</span><em>rgb_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_binary" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB888格式的元组(r, g, b)对应的中心范围阈值二进制值(0-1)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB888-&gt;RGB565进程进行转换，因此此方法不会像纯RGB888系统那样返回准确的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.rgb_to_grayscale">
<code class="descclassname">image.</code><code class="descname">rgb_to_grayscale</code><span class="sig-paren">(</span><em>rgb_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_grayscale" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB888格式的元组(r, g, b)对应的灰度值(0-255)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB888-&gt;RGB565进程进行转换，因此此方法不会像纯RGB888系统那样返回准确的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.rgb_to_lab">
<code class="descclassname">image.</code><code class="descname">rgb_to_lab</code><span class="sig-paren">(</span><em>rgb_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_lab" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB888格式的元组(r, g, b)对应的LAB格式的元组(l, a, b)。</p>
<p>L的范围为0到100, A和B的范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB888-&gt;RGB565进程进行转换，因此此方法不会像纯RGB888系统那样返回准确的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.rgb_to_yuv">
<code class="descclassname">image.</code><code class="descname">rgb_to_yuv</code><span class="sig-paren">(</span><em>rgb_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_yuv" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB888格式的元组(r, g, b)对应的YUV格式的元组(y, u, v)。</p>
<p>Y的范围为0到255, U和V范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用RGB888-&gt;RGB565进程进行转换，因此此方法不会像纯RGB888系统那样返回准确的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.lab_to_binary">
<code class="descclassname">image.</code><code class="descname">lab_to_binary</code><span class="sig-paren">(</span><em>lab_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_binary" title="永久链接至目标">¶</a></dt>
<dd><p>返回LAB格式的元组(l, a, b)对应的中心范围阈值二进制值(0-1)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用LAB-&gt;RGB565进程进行转换，因此此方法不会像纯LAB系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.lab_to_grayscale">
<code class="descclassname">image.</code><code class="descname">lab_to_grayscale</code><span class="sig-paren">(</span><em>lab_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_grayscale" title="永久链接至目标">¶</a></dt>
<dd><p>返回LAB格式的元组(l, a, b)对应的灰度值(0-255)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用LAB-&gt;RGB565进程进行转换，因此此方法不会像纯LAB系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.lab_to_rgb">
<code class="descclassname">image.</code><code class="descname">lab_to_rgb</code><span class="sig-paren">(</span><em>lab_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_rgb" title="永久链接至目标">¶</a></dt>
<dd><p>返回LAB格式的元组 <code class="docutils literal notranslate"><span class="pre">lab_tuple</span></code> (l, a, b)对应的RGB888格式的元组(r, g, b)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用LAB-&gt;RGB565进程进行转换，因此此方法不会像纯LAB系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.lab_to_yuv">
<code class="descclassname">image.</code><code class="descname">lab_to_yuv</code><span class="sig-paren">(</span><em>lab_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_yuv" title="永久链接至目标">¶</a></dt>
<dd><p>返回LAB格式的元组(l, a, b)对应的YUV格式的元组(y, u, v)。</p>
<p>Y的范围为0到255, U和V范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用LAB-&gt;RGB565进程进行转换，因此此方法不会像纯LAB系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.yuv_to_binary">
<code class="descclassname">image.</code><code class="descname">yuv_to_binary</code><span class="sig-paren">(</span><em>yuv_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_binary" title="永久链接至目标">¶</a></dt>
<dd><p>返回YUV格式的元组(y, u, v)对应的中心范围阈值二进制值(0-1)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用YUV-&gt;RGB565进程进行转换，因此此方法不会像纯YUV系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.yuv_to_grayscale">
<code class="descclassname">image.</code><code class="descname">yuv_to_grayscale</code><span class="sig-paren">(</span><em>yuv_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_grayscale" title="永久链接至目标">¶</a></dt>
<dd><p>返回YUV格式的元组(y, u, v)对应的灰度值(0-255)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用YUV-&gt;RGB565进程进行转换，因此此方法不会像纯YUV系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.yuv_to_rgb">
<code class="descclassname">image.</code><code class="descname">yuv_to_rgb</code><span class="sig-paren">(</span><em>lab_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_rgb" title="永久链接至目标">¶</a></dt>
<dd><p>返回YUV格式的元组(y, u, v)对应的RGB888格式的元组(r, g, b)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用YUV-&gt;RGB565进程进行转换，因此此方法不会像纯YUV系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.yuv_to_lab">
<code class="descclassname">image.</code><code class="descname">yuv_to_lab</code><span class="sig-paren">(</span><em>yuv_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_lab" title="永久链接至目标">¶</a></dt>
<dd><p>返回YUV格式的元组(y, u, v)对应的LAB格式的元组(l, a, b)。</p>
<p>L的范围为0到100, A和B的范围为-128到128。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">OpenMV Cam固件使用YUV-&gt;RGB565进程进行转换，因此此方法不会像纯YUV系统那样返回确切的值。
但是，图像库在内部这样工作是正确的。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="image.load_descriptor">
<code class="descclassname">image.</code><code class="descname">load_descriptor</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#image.load_descriptor" title="永久链接至目标">¶</a></dt>
<dd><p>从磁盘上加载一个描述符对象(descriptor object).</p>
<p><code class="docutils literal notranslate"><span class="pre">path</span></code> 是描述符文件保存的路径。</p>
</dd></dl>

<dl class="function">
<dt id="image.save_descriptor">
<code class="descclassname">image.</code><code class="descname">save_descriptor</code><span class="sig-paren">(</span><em>path</em>, <em>descriptor</em><span class="sig-paren">)</span><a class="headerlink" href="#image.save_descriptor" title="永久链接至目标">¶</a></dt>
<dd><p>保存描述符对象&nbsp;<code class="docutils literal notranslate"><span class="pre">descriptor</span></code>&nbsp;到磁盘。</p>
<p><code class="docutils literal notranslate"><span class="pre">path</span></code> 是描述符文件保存的路径。</p>
</dd></dl>

<dl class="function">
<dt id="image.match_descriptor">
<code class="descclassname">image.</code><code class="descname">match_descriptor</code><span class="sig-paren">(</span><em>descritor0</em>, <em>descriptor1</em><span class="optional">[</span>, <em>threshold=70</em><span class="optional">[</span>, <em>filter_outliers=False</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.match_descriptor" title="永久链接至目标">¶</a></dt>
<dd><p>对于LBP描述符来说，这个函数返回的是一个体现两个描述符之间区别的整数。这一距离测度尤为必要。这个距离是对相似度的一个度量。这个测度值越接近0，LBPF特征点匹配得就越好。</p>
<p>对于ORB描述符来说，这个函数返回的是kptmatch对象。见上。</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 是用来为ORB键点过滤不明确匹配服务的。</div></blockquote>
<p>一个较低的 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 值将紧扣关键点匹配算法。
<code class="docutils literal notranslate"><span class="pre">threshold</span></code>&nbsp;值位于0-100 (int)。默认值为70。</p>
<p><code class="docutils literal notranslate"><span class="pre">filter_outliers</span></code>&nbsp;是用来为ORB键点过滤异常值服务的。
特征点允许用户提高 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 值。默认设置为False。</p>
</dd></dl>

</div>
</div>
<div class="section" id="haarcascade">
<h1>HaarCascade 类 – 特征描述符<a class="headerlink" href="#haarcascade" title="永久链接至标题">¶</a></h1>
<p>Haar Cascade特征描述符用于 <a class="reference internal" href="#image.find_features" title="image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_features()</span></code></a>&nbsp;方法。它没有供用户调用的方法。</p>
<div class="section" id="id2">
<h2>构造函数<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.HaarCascade">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">HaarCascade</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>stages=Auto</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.HaarCascade" title="永久链接至目标">¶</a></dt>
<dd><p>从一个Haar Cascade二进制文件（适合OpenMV Cam的格式）加载一个Haar Cascade。
如果您传递“frontalface”字符串 而非一条路径，这个构造函数将会把一个内置的正脸Haar Cascade载入内存。
此外，您也可以通过“eye”来把Haar Cascade载入内存。
最后，这个方法会返回载入的Haar Cascade对象，用来使用 <a class="reference internal" href="#image.find_features" title="image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_features()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">stages</span></code>&nbsp;默认值为Haar Cascade中的阶段数。然而，您可以指定一个较低的数值来加速运行特征检测器，当然这会带来较高的误报率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">您可以制作自己的Haar Cascades 来配合您的OpenMV Cam 使用。
首先，使用谷歌搜索“&lt;thing&gt; Haar Cascade”，检测是否有人已经为您想要检测的对象制作了OpenCV Haar Cascade。
如果没有，那您需要自己动手制作（工作量巨大）。
关于如何制作自己的Haar Cascade，<a class="reference external" href="http://coding-robin.de/2013/07/22/train-your-own-opencv-haar-classifier.html">见此</a>
关于如何把OpenCV Haar Cascades转化成您的OpenMV Cam可以读取的模式，
<a class="reference external" href="https://github.com/openmv/openmv/blob/master/usr/openmv-cascade.py">见此script</a></p>
</div>
<p>问：Haar Cascade 是什么？</p>
<p>答：Haar Cascade是一系列用来确定一个对象是否存在于图像中的对比检查。
这一系列的对比检查分成了多个阶段，后一阶段的运行以先前阶段的完成为前提。
对比检查并不复杂，不过是像检查图像的中心垂直是否比边缘更轻微之类的过程。
大范围的检查在前期阶段首先进行，在后期进行更多更小的区域检查。</p>
<p>问：Haar Cascades 是如何制作而成的？</p>
<p>答：Haar Cascades通过标有正负的图像对发生器算法进行训练。
比如，用数百张含有猫（已被标记为内含猫）的图片和数百张不含有猫形物的图片（已作出不同标记）来训练这个生成算法。
这个生成算法最后会产生一个用来检测猫的Haar Cascades。</p>
</dd></dl>

</div>
</div>
<div class="section" id="similarity">
<h1>Similarity 类 – 相似度对象<a class="headerlink" href="#similarity" title="永久链接至标题">¶</a></h1>
<p>相似度对象由 <code class="docutils literal notranslate"><span class="pre">image.get_similarity</span></code> 返回.</p>
<div class="section" id="id4">
<h2>构造函数<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.similarity">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">similarity</code><a class="headerlink" href="#image.similarity" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.get_similarity" title="image.get_similarity"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_similarity()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id5">
<h2>方法<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="similarity.mean">
<code class="descclassname">similarity.</code><code class="descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#similarity.mean" title="永久链接至目标">¶</a></dt>
<dd><p>返回8x8像素块结构相似性差异的均值。范围[-1/+1]，其中
-1完全不同，+1完全相同。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="similarity.stdev">
<code class="descclassname">similarity.</code><code class="descname">stdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#similarity.stdev" title="永久链接至目标">¶</a></dt>
<dd><p>返回8x8像素块结构相似性差异的标准偏差。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="similarity.min">
<code class="descclassname">similarity.</code><code class="descname">min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#similarity.min" title="永久链接至目标">¶</a></dt>
<dd><p>返回8x8像素块结构相似性差异的最小值。其中
-1完全不同，+1完全相同。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否差别很大，即远远低于+1。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="similarity.max">
<code class="descclassname">similarity.</code><code class="descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#similarity.max" title="永久链接至目标">¶</a></dt>
<dd><p>返回8x8像素块结构相似性差异的最小值。其中
-1完全不同，+1完全相同。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">通过查看此值，您可以快速确定两个图像之间的任何8x8像素块是否都相同。即比-1大很多。</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="histogram">
<h1>Histogram 类 – 直方图对象<a class="headerlink" href="#histogram" title="永久链接至标题">¶</a></h1>
<p>直方图对象是由 <a class="reference internal" href="#image.get_histogram" title="image.get_histogram"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_histogram</span></code></a> 返回。 灰度直方图有一个包含多个二进制的通道。
所有二进制都进行标准化，使其总和为1。
RGB565有三个包含多个二进制的通道。所有二进制都进行标准化，使其总和为1。</p>
<div class="section" id="id6">
<h2>构造函数<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.histogram">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">histogram</code><a class="headerlink" href="#image.histogram" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.get_histogram" title="image.get_histogram"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_histogram()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id7">
<h2>方法<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="histogram.bins">
<code class="descclassname">histogram.</code><code class="descname">bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度直方图的浮点数列表。
您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.l_bins">
<code class="descclassname">histogram.</code><code class="descname">l_bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.l_bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565直方图LAB的L通道的浮点数列表。
您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.a_bins">
<code class="descclassname">histogram.</code><code class="descname">a_bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.a_bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565直方图LAB的A通道的浮点数列表。
您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.b_bins">
<code class="descclassname">histogram.</code><code class="descname">b_bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.b_bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565直方图LAB的B通道的浮点数列表。
您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.get_percentile">
<code class="descclassname">histogram.</code><code class="descname">get_percentile</code><span class="sig-paren">(</span><em>percentile</em><span class="sig-paren">)</span><a class="headerlink" href="#histogram.get_percentile" title="永久链接至目标">¶</a></dt>
<dd><p>计算直方图频道的CDF，返回一个传递&nbsp;<code class="docutils literal notranslate"><span class="pre">percentile</span></code>&nbsp;(0.0 - 1.0) (浮点数)中的直方图的值。</p>
<p>因此，若您传入0.1，该方法会告知您，当累加入累加器时，哪一个二进制会使累加器跨过0.1。</p>
<p>在没有异常效用破坏您的自适应色跟踪结果时，这对于确定颜色分布的最小值(0.1)和max(0.9)甚是有效。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.get_threhsold">
<code class="descclassname">histogram.</code><code class="descname">get_threhsold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.get_threhsold" title="永久链接至目标">¶</a></dt>
<dd><p>使用Otsu’s 方法计算最佳阈值，将直方图分的每个通道为两半。 该方法返回一个 <a class="reference internal" href="#image.threshold" title="image.threshold"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.threshold</span></code></a> 对象。
这个方法对确定最佳的 <a class="reference internal" href="#image.binary" title="image.binary"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.binary()</span></code></a> 阈值特别有用。</p>
</dd></dl>

<dl class="method">
<dt id="histogram.get_statistics">
<code class="descclassname">histogram.</code><code class="descname">get_statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#histogram.get_statistics" title="永久链接至目标">¶</a></dt>
<dd><p>计算直方图中每个颜色通道的平均值、中值、众值、标准差、最小值、最大值、下四分值和上四分值，
并返回一个statistics对象。
您也可以使用 <code class="docutils literal notranslate"><span class="pre">histogram.statistics()</span></code>&nbsp;和 <code class="docutils literal notranslate"><span class="pre">histogram.get_stats()</span></code>&nbsp;作为这个方法的别名。</p>
</dd></dl>

</div>
</div>
<div class="section" id="percentile">
<h1>Percentile 类 – 百分比值对象<a class="headerlink" href="#percentile" title="永久链接至标题">¶</a></h1>
<p>百分比值对象由 <a class="reference internal" href="#histogram.get_percentile" title="histogram.get_percentile"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_percentile</span></code></a> 返回。
灰度百分比值有一个通道。不使用&nbsp;<code class="docutils literal notranslate"><span class="pre">l_*</span></code> 、&nbsp;<code class="docutils literal notranslate"><span class="pre">a_*</span></code> 或&nbsp;<code class="docutils literal notranslate"><span class="pre">b_*</span></code> 方法。
RGB565百分比值有三个通道。使用&nbsp;<code class="docutils literal notranslate"><span class="pre">l_*</span></code> 、&nbsp;<code class="docutils literal notranslate"><span class="pre">a_*</span></code> 和&nbsp;<code class="docutils literal notranslate"><span class="pre">b_*</span></code> 方法。</p>
<div class="section" id="id8">
<h2>构造函数<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.percentile">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">percentile</code><a class="headerlink" href="#image.percentile" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#histogram.get_percentile" title="histogram.get_percentile"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_percentile()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id9">
<h2>方法<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="percentile.value">
<code class="descclassname">percentile.</code><code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#percentile.value" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度百分比值（取值区间为0-255）。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="percentile.l_value">
<code class="descclassname">percentile.</code><code class="descname">l_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#percentile.l_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565 LAB 的L通道的百分比值（取值区间为0-100）。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="percentile.a_value">
<code class="descclassname">percentile.</code><code class="descname">a_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#percentile.a_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565 LAB 的A通道的百分比值（取值区间为-128-127）。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="percentile.b_value">
<code class="descclassname">percentile.</code><code class="descname">b_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#percentile.b_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565 LAB 的B通道的百分比值（取值区间为-128-127）。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="threhsold">
<h1>Threhsold 类 – 阈值对象<a class="headerlink" href="#threhsold" title="永久链接至标题">¶</a></h1>
<p>阈值对象由 <code class="docutils literal notranslate"><span class="pre">histogram.get_threshold</span></code> 返回。</p>
<p>灰度图像有一个通道。没有 <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, 和
<code class="docutils literal notranslate"><span class="pre">b_*</span></code> 方法.</p>
<p>RGB565 阈值有三个通道。使用 <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">b_*</span></code>
方法。</p>
<div class="section" id="id10">
<h2>构造函数<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.threshold">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">threshold</code><a class="headerlink" href="#image.threshold" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <code class="xref any docutils literal notranslate"><span class="pre">histogram.get_threshold()</span></code> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id11">
<h2>方法<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="threhsold.value">
<code class="descclassname">threhsold.</code><code class="descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threhsold.value" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度图的阈值 (between 0 and 255)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="threhsold.l_value">
<code class="descclassname">threhsold.</code><code class="descname">l_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threhsold.l_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565图LAB中的L阈值 (between 0 and 100).</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="threhsold.a_value">
<code class="descclassname">threhsold.</code><code class="descname">a_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threhsold.a_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565图LAB中的A阈值 (between -128 and 127).</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="threhsold.b_value">
<code class="descclassname">threhsold.</code><code class="descname">b_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threhsold.b_value" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB565图LAB中的B阈值 (between -128 and 127).</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-statistics">
<h1>class Statistics – 统计数据对象<a class="headerlink" href="#class-statistics" title="永久链接至标题">¶</a></h1>
<p>统计数据对象是由 <code class="docutils literal notranslate"><span class="pre">histogram.get_statistics</span></code>
或&nbsp;<code class="docutils literal notranslate"><span class="pre">image.get_statistics</span></code> 返回的。</p>
<p>灰度统计数据有一个通道，使用非&nbsp;<code class="docutils literal notranslate"><span class="pre">l_*</span></code> 、&nbsp;<code class="docutils literal notranslate"><span class="pre">a_*</span></code> 或&nbsp;<code class="docutils literal notranslate"><span class="pre">b_*</span></code> 方法。</p>
<p>RGB565百分比值有三个通道。使用&nbsp;<code class="docutils literal notranslate"><span class="pre">l_*</span></code> 、&nbsp;<code class="docutils literal notranslate"><span class="pre">a_*</span></code> 和&nbsp;<code class="docutils literal notranslate"><span class="pre">b_*</span></code> 方法。</p>
<div class="section" id="id12">
<h2>构造函数<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.statistics">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">statistics</code><a class="headerlink" href="#image.statistics" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#histogram.get_statistics" title="histogram.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_statistics()</span></code></a> 或 <a class="reference internal" href="#image.get_statistics" title="image.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_statistics()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id13">
<h2>方法<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="statistics.mean">
<code class="descclassname">statistics.</code><code class="descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.mean" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度均值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.median">
<code class="descclassname">statistics.</code><code class="descname">median</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.median" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度中值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.mode">
<code class="descclassname">statistics.</code><code class="descname">mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.mode" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度众值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.stdev">
<code class="descclassname">statistics.</code><code class="descname">stdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.stdev" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度标准差(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.min">
<code class="descclassname">statistics.</code><code class="descname">min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.min" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度最小值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.max">
<code class="descclassname">statistics.</code><code class="descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.max" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度最大值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.lq">
<code class="descclassname">statistics.</code><code class="descname">lq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.lq" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度下四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.uq">
<code class="descclassname">statistics.</code><code class="descname">uq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.uq" title="永久链接至目标">¶</a></dt>
<dd><p>返回灰度上四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_mean">
<code class="descclassname">statistics.</code><code class="descname">l_mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_mean" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的均值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_median">
<code class="descclassname">statistics.</code><code class="descname">l_median</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_median" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的中值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_mode">
<code class="descclassname">statistics.</code><code class="descname">l_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_mode" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的众值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_stdev">
<code class="descclassname">statistics.</code><code class="descname">l_stdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_stdev" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的标准偏差值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_min">
<code class="descclassname">statistics.</code><code class="descname">l_min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_min" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的最小值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_max">
<code class="descclassname">statistics.</code><code class="descname">l_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_max" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的最大值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_lq">
<code class="descclassname">statistics.</code><code class="descname">l_lq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_lq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的下四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.l_uq">
<code class="descclassname">statistics.</code><code class="descname">l_uq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.l_uq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中L的上四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_mean">
<code class="descclassname">statistics.</code><code class="descname">a_mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_mean" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的均值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_median">
<code class="descclassname">statistics.</code><code class="descname">a_median</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_median" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的中值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[9]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_mode">
<code class="descclassname">statistics.</code><code class="descname">a_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_mode" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的众值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_stdev">
<code class="descclassname">statistics.</code><code class="descname">a_stdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_stdev" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的标准偏差值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[11]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_min">
<code class="descclassname">statistics.</code><code class="descname">a_min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_min" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的最小值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[12]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_max">
<code class="descclassname">statistics.</code><code class="descname">a_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_max" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的最大值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[13]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_lq">
<code class="descclassname">statistics.</code><code class="descname">a_lq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_lq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的下四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[14]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.a_uq">
<code class="descclassname">statistics.</code><code class="descname">a_uq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.a_uq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中A的上四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[15]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_mean">
<code class="descclassname">statistics.</code><code class="descname">b_mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_mean" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的均值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[16]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_median">
<code class="descclassname">statistics.</code><code class="descname">b_median</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_median" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的中值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[17]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_mode">
<code class="descclassname">statistics.</code><code class="descname">b_mode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_mode" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的众值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[18]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_stdev">
<code class="descclassname">statistics.</code><code class="descname">b_stdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_stdev" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的标准差值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[19]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_min">
<code class="descclassname">statistics.</code><code class="descname">b_min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_min" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的最小值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[20]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_max">
<code class="descclassname">statistics.</code><code class="descname">b_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_max" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的最大值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[21]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_lq">
<code class="descclassname">statistics.</code><code class="descname">b_lq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_lq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的下四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[22]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="statistics.b_uq">
<code class="descclassname">statistics.</code><code class="descname">b_uq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#statistics.b_uq" title="永久链接至目标">¶</a></dt>
<dd><p>返回RGB5656 LAB 中B的上四分值(0-255) (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[23]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="blob">
<h1>Blob 类 – 色块对象<a class="headerlink" href="#blob" title="永久链接至标题">¶</a></h1>
<p>色块对象是由&nbsp;<code class="docutils literal notranslate"><span class="pre">image.find_blobs</span></code> 返回的。</p>
<div class="section" id="id14">
<h2>构造函数<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.blob">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">blob</code><a class="headerlink" href="#image.blob" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_blobs" title="image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_blobs()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id15">
<h2>方法<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="blob.corners">
<code class="descclassname">blob.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的4个角的4 (x,y)元组列表。从左上方开始按顺时针顺序返回角。</p>
</dd></dl>

<dl class="method">
<dt id="blob.min_corners">
<code class="descclassname">blob.</code><code class="descname">min_corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.min_corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含4个角的4 (x,y)元组的列表，该元组的边界大于该Blob的最小面积矩形的边界。
与 <a class="reference internal" href="#blob.corners" title="blob.corners"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.corners()</span></code></a> 不同，最小面积矩形的角并不一定位于blob上。</p>
</dd></dl>

<dl class="method">
<dt id="blob.rect">
<code class="descclassname">blob.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h) ，用于如色块边界框的&nbsp;<a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等
其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="blob.x">
<code class="descclassname">blob.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块的边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.y">
<code class="descclassname">blob.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块的边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.w">
<code class="descclassname">blob.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块的边界框的w坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.h">
<code class="descclassname">blob.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块的边界框的h坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.pixels">
<code class="descclassname">blob.</code><code class="descname">pixels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.pixels" title="永久链接至目标">¶</a></dt>
<dd><p>返回从属于色块(int)一部分的像素数量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.cx">
<code class="descclassname">blob.</code><code class="descname">cx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.cx" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块(int)的中心x位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.cxf">
<code class="descclassname">blob.</code><code class="descname">cxf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.cxf" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob(浮点数)的质心x位置。</p>
</dd></dl>

<dl class="method">
<dt id="blob.cy">
<code class="descclassname">blob.</code><code class="descname">cy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.cy" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块(int)的中心x位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.cyf">
<code class="descclassname">blob.</code><code class="descname">cyf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.cyf" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob(浮点数)的质心y位置。</p>
</dd></dl>

<dl class="method">
<dt id="blob.rotation">
<code class="descclassname">blob.</code><code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块的旋转（单位：弧度）。如果色块类似铅笔或钢笔，那么这个值就是介于0-180之间的唯一值。
如果这个色块圆的，那么这个值就没有效用。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.rotation_deg">
<code class="descclassname">blob.</code><code class="descname">rotation_deg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.rotation_deg" title="永久链接至目标">¶</a></dt>
<dd><p>以度为单位返回blob的旋转角度。</p>
</dd></dl>

<dl class="method">
<dt id="blob.rotation_rad">
<code class="descclassname">blob.</code><code class="descname">rotation_rad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.rotation_rad" title="永久链接至目标">¶</a></dt>
<dd><p>以弧度为单位返回blob的旋转度数。这个方法比 <a class="reference internal" href="#blob.rotation" title="blob.rotation"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.rotation()</span></code></a> 更具描述性。</p>
</dd></dl>

<dl class="method">
<dt id="blob.code">
<code class="descclassname">blob.</code><code class="descname">code</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.code" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个32位的二进制数字，其中为每个颜色阈值设置一个位，这是色块的一部分。
例如，如果您通过 <a class="reference internal" href="#image.find_blobs" title="image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_blobs</span></code></a> 来寻找三个颜色阈值，这个色块可以设置为0/1/2位。
注意：除非以 <code class="docutils literal notranslate"><span class="pre">merge=True</span></code>
调用 <a class="reference internal" href="#image.find_blobs" title="image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_blobs</span></code></a> ，否则每个色块只能设置一位。
那么颜色阈值不同的多个色块就可以合并在一起了。
您也可以用这个方法以及多个阈值来实现颜色代码跟踪。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.count">
<code class="descclassname">blob.</code><code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.count" title="永久链接至目标">¶</a></dt>
<dd><p>返回合并到此Blob中的Blob数。 只有您以 <code class="docutils literal notranslate"><span class="pre">merge=True</span></code>
调用 <a class="reference internal" href="#image.find_blobs" title="image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_blobs</span></code></a> 时，这个数字才不是1。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[9]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="blob.perimeter">
<code class="descclassname">blob.</code><code class="descname">perimeter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.perimeter" title="永久链接至目标">¶</a></dt>
<dd><p>返回该blob周长上的像素数。</p>
</dd></dl>

<dl class="method">
<dt id="blob.roundness">
<code class="descclassname">blob.</code><code class="descname">roundness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.roundness" title="永久链接至目标">¶</a></dt>
<dd><p>返回0到1之间的值，表示对象的圆度。一个圆将是1。</p>
</dd></dl>

<dl class="method">
<dt id="blob.elongation">
<code class="descclassname">blob.</code><code class="descname">elongation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.elongation" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个介于0和1之间的值，该值表示对象的长度（不是圆形）。一条线将是1。</p>
</dd></dl>

<dl class="method">
<dt id="blob.area">
<code class="descclassname">blob.</code><code class="descname">area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.area" title="永久链接至目标">¶</a></dt>
<dd><p>返回色块周围的边框面积(w * h)</p>
</dd></dl>

<dl class="method">
<dt id="blob.density">
<code class="descclassname">blob.</code><code class="descname">density</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.density" title="永久链接至目标">¶</a></dt>
<dd><p>返回这个色块的密度比。这是在色块边界框区域内的像素点的数量。
总的来说，较低的密度比意味着这个对象的锁定得不是很好。
结果在0和1之间。</p>
</dd></dl>

<dl class="method">
<dt id="blob.extent">
<code class="descclassname">blob.</code><code class="descname">extent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.extent" title="永久链接至目标">¶</a></dt>
<dd><p>是 <a class="reference internal" href="#blob.density" title="blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a> 的别名。</p>
</dd></dl>

<dl class="method">
<dt id="blob.compactness">
<code class="descclassname">blob.</code><code class="descname">compactness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.compactness" title="永久链接至目标">¶</a></dt>
<dd><p>类似 <a class="reference internal" href="#blob.density" title="blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a> ，但是，使用blob的周长来衡量对象的密度，因此更准确。结果在0和1之间。</p>
</dd></dl>

<dl class="method">
<dt id="blob.solidity">
<code class="descclassname">blob.</code><code class="descname">solidity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.solidity" title="永久链接至目标">¶</a></dt>
<dd><p>类似 <a class="reference internal" href="#blob.density" title="blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a> ，但是，使用旋转的最小面积矩形与边界矩形来衡量密度。结果在0和1之间。</p>
</dd></dl>

<dl class="method">
<dt id="blob.convexity">
<code class="descclassname">blob.</code><code class="descname">convexity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.convexity" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个0到1之间的值，表示对象的凸度。正方形是1。</p>
</dd></dl>

<dl class="method">
<dt id="blob.x_hist_bins">
<code class="descclassname">blob.</code><code class="descname">x_hist_bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.x_hist_bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob中所有列的x轴直方图。Bin值在0和1之间缩放。</p>
</dd></dl>

<dl class="method">
<dt id="blob.y_hist_bins">
<code class="descclassname">blob.</code><code class="descname">y_hist_bins</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.y_hist_bins" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob中所有行的y轴直方图。Bin值在0和1之间缩放。</p>
</dd></dl>

<dl class="method">
<dt id="blob.major_axis_line">
<code class="descclassname">blob.</code><code class="descname">major_axis_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.major_axis_line" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob的主轴(这条线穿过最小面积矩形的最长边)的行元组(x1, y1, x2, y2)，可以使用 <a class="reference internal" href="#image.draw_line" title="image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_line()</span></code></a> 来绘制它。</p>
</dd></dl>

<dl class="method">
<dt id="blob.minor_axis_line">
<code class="descclassname">blob.</code><code class="descname">minor_axis_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.minor_axis_line" title="永久链接至目标">¶</a></dt>
<dd><p>返回blob的次轴(这条线穿过最小面积矩形的最短边)的行元组(x1, y1, x2, y2)，可以使用 <a class="reference internal" href="#image.draw_line" title="image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_line()</span></code></a> 来绘制它。</p>
</dd></dl>

<dl class="method">
<dt id="blob.enclosing_circle">
<code class="descclassname">blob.</code><code class="descname">enclosing_circle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.enclosing_circle" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个圆（包围blob的最小面积矩形的圆）元组(x, y, r)，可以使用 <a class="reference internal" href="#image.draw_circle" title="image.draw_circle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_circle()</span></code></a> 来绘制它。</p>
</dd></dl>

<dl class="method">
<dt id="blob.enclosed_ellipse">
<code class="descclassname">blob.</code><code class="descname">enclosed_ellipse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blob.enclosed_ellipse" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个椭圆（包围blob的最小面积矩形的椭圆）元组(x, y, rx, ry, rotation)，可以使用 <a class="reference internal" href="#image.draw_ellipse" title="image.draw_ellipse"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_ellipse()</span></code></a> 来绘制它。</p>
</dd></dl>

</div>
</div>
<div class="section" id="line">
<h1>Line类 – 直线对象<a class="headerlink" href="#line" title="永久链接至标题">¶</a></h1>
<p>直线对象是由 <a class="reference internal" href="#image.find_lines" title="image.find_lines"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_lines</span></code></a> ,&nbsp;<a class="reference internal" href="#image.find_line_segments" title="image.find_line_segments"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_line_segments</span></code></a> 或&nbsp; <a class="reference internal" href="#image.get_regression" title="image.get_regression"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_regression</span></code></a> 返回的。</p>
<div class="section" id="id16">
<h2>构造函数<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.line">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">line</code><a class="headerlink" href="#image.line" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_lines" title="image.find_lines"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_lines()</span></code></a>, <a class="reference internal" href="#image.find_line_segments" title="image.find_line_segments"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_line_segments()</span></code></a>, 或 <a class="reference internal" href="#image.get_regression" title="image.get_regression"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_regression()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id17">
<h2>方法<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="line.line">
<code class="descclassname">line.</code><code class="descname">line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.line" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个直线元组(x1, y1, x2, y2) ，用于如 <a class="reference internal" href="#image.draw_line" title="image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_line</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="line.x1">
<code class="descclassname">line.</code><code class="descname">x1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.x1" title="永久链接至目标">¶</a></dt>
<dd><p>返回直线的p1顶点 x坐标分量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.y1">
<code class="descclassname">line.</code><code class="descname">y1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.y1" title="永久链接至目标">¶</a></dt>
<dd><p>返回直线的p1 y分量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.x2">
<code class="descclassname">line.</code><code class="descname">x2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.x2" title="永久链接至目标">¶</a></dt>
<dd><p>返回直线的p2 x分量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.y2">
<code class="descclassname">line.</code><code class="descname">y2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.y2" title="永久链接至目标">¶</a></dt>
<dd><p>返回直线的p2 y分量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.length">
<code class="descclassname">line.</code><code class="descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.length" title="永久链接至目标">¶</a></dt>
<dd><p>返回直线长度即 sqrt(((x2-x1)^2) + ((y2-y1)^2).</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.magnitude">
<code class="descclassname">line.</code><code class="descname">magnitude</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.magnitude" title="永久链接至目标">¶</a></dt>
<dd><p>返回霍夫变换后的直线的模(magnitude)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.theta">
<code class="descclassname">line.</code><code class="descname">theta</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.theta" title="永久链接至目标">¶</a></dt>
<dd><p>返回霍夫变换后的直线的角度（0-179度）。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="line.rho">
<code class="descclassname">line.</code><code class="descname">rho</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#line.rho" title="永久链接至目标">¶</a></dt>
<dd><p>返回霍夫变换后的直线p值。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="circle">
<h1>Circle类 –圆形对象<a class="headerlink" href="#circle" title="永久链接至标题">¶</a></h1>
<p>圆形对象是由&nbsp;<a class="reference internal" href="#image.find_circles" title="image.find_circles"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_circles</span></code></a> 返回的。</p>
<div class="section" id="id18">
<h2>构造函数<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.circle">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">circle</code><a class="headerlink" href="#image.circle" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_circles" title="image.find_circles"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_circles()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id19">
<h2>方法<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="circle.x">
<code class="descclassname">circle.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circle.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回圆的x位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="circle.y">
<code class="descclassname">circle.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circle.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回圆的y位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="circle.r">
<code class="descclassname">circle.</code><code class="descname">r</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circle.r" title="永久链接至目标">¶</a></dt>
<dd><p>返回圆的半径。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="circle.magnitude">
<code class="descclassname">circle.</code><code class="descname">magnitude</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circle.magnitude" title="永久链接至目标">¶</a></dt>
<dd><p>返回圆的模(magnitude)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="rect">
<h1>Rect类 – 矩形对象<a class="headerlink" href="#rect" title="永久链接至标题">¶</a></h1>
<p>矩形对象是由 <a class="reference internal" href="#image.find_rects" title="image.find_rects"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_rects</span></code></a> 返回的。</p>
<div class="section" id="id20">
<h2>构造函数<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.rect">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">rect</code><a class="headerlink" href="#image.rect" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_rects" title="image.find_rects"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_rects()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id21">
<h2>方法<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="rect.corners">
<code class="descclassname">rect.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由矩形对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。</p>
</dd></dl>

<dl class="method">
<dt id="rect.rect">
<code class="descclassname">rect.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如&nbsp;矩形的边界框的 <a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="rect.x">
<code class="descclassname">rect.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回矩形的左上角的x位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="rect.y">
<code class="descclassname">rect.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回矩形的左上角的y位置。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="rect.w">
<code class="descclassname">rect.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回矩形的宽度。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="rect.h">
<code class="descclassname">rect.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回矩形的高度。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="rect.magnitude">
<code class="descclassname">rect.</code><code class="descname">magnitude</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rect.magnitude" title="永久链接至目标">¶</a></dt>
<dd><p>返回矩形的模(magnitude)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="qrcode">
<h1>QRCode类 – 二维码对象<a class="headerlink" href="#qrcode" title="永久链接至标题">¶</a></h1>
<p>二维码对象是由 <a class="reference internal" href="#image.find_qrcodes" title="image.find_qrcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_qrcodes</span></code></a> 返回的。</p>
<div class="section" id="id22">
<h2>构造函数<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.qrcode">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">qrcode</code><a class="headerlink" href="#image.qrcode" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_qrcodes" title="image.find_qrcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_qrcodes()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id23">
<h2>方法<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="qrcode.corners">
<code class="descclassname">qrcode.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.rect">
<code class="descclassname">qrcode.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如二维码的边界框的 <code class="docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code> 等其他的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.x">
<code class="descclassname">qrcode.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.y">
<code class="descclassname">qrcode.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.w">
<code class="descclassname">qrcode.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的边界框的w坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.h">
<code class="descclassname">qrcode.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的边界框的h坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.payload">
<code class="descclassname">qrcode.</code><code class="descname">payload</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.payload" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码有效载荷的字符串，例如URL 。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.version">
<code class="descclassname">qrcode.</code><code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.version" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的版本号(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.ecc_level">
<code class="descclassname">qrcode.</code><code class="descname">ecc_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.ecc_level" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的ECC水平(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.mask">
<code class="descclassname">qrcode.</code><code class="descname">mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.mask" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的掩码(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.data_type">
<code class="descclassname">qrcode.</code><code class="descname">data_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.data_type" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的数据类型。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.eci">
<code class="descclassname">qrcode.</code><code class="descname">eci</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.eci" title="永久链接至目标">¶</a></dt>
<dd><p>返回二维码的ECI。ECI储存了QR码中存储数据字节的编码。若您想要处理包含超过标准ASCII文本的二维码，您需要查看这一数值。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[9]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.is_numeric">
<code class="descclassname">qrcode.</code><code class="descname">is_numeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.is_numeric" title="永久链接至目标">¶</a></dt>
<dd><p>若二维码的数据类型为数字式，则返回True。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.is_alphanumeric">
<code class="descclassname">qrcode.</code><code class="descname">is_alphanumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.is_alphanumeric" title="永久链接至目标">¶</a></dt>
<dd><p>若二维码的数据类型为文字数字式，则返回True。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.is_binary">
<code class="descclassname">qrcode.</code><code class="descname">is_binary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.is_binary" title="永久链接至目标">¶</a></dt>
<dd><p>若二维码的数据类型为二进制式，则返回True。如果您认真处理所有类型的文本，则需要检查eci是否为True，以确定数据的文本编码。通常它只是标准的ASCII，但是它也可能是有两个字节字符的UTF8。</p>
</dd></dl>

<dl class="method">
<dt id="qrcode.is_kanji">
<code class="descclassname">qrcode.</code><code class="descname">is_kanji</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qrcode.is_kanji" title="永久链接至目标">¶</a></dt>
<dd><p>若二维码的数据类型为日本汉字，则返回True。设置为True后，您就需要自行解码字符串，因为日本汉字符号每个字符是10位，而MicroPython不支持解析这类文本。</p>
</dd></dl>

</div>
</div>
<div class="section" id="apriltag-apriltag">
<h1>AprilTag类 – AprilTag对象<a class="headerlink" href="#apriltag-apriltag" title="永久链接至标题">¶</a></h1>
<p>AprilTag对象是由 <a class="reference internal" href="#image.find_apriltags" title="image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_apriltags</span></code></a> 返回的。</p>
<div class="section" id="id24">
<h2>构造函数<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.apriltag">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">apriltag</code><a class="headerlink" href="#image.apriltag" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_apriltags" title="image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_apriltags()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id25">
<h2>方法<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="apriltag.corners">
<code class="descclassname">apriltag.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.rect">
<code class="descclassname">apriltag.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如AprilTag边界框的 <a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.x">
<code class="descclassname">apriltag.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.y">
<code class="descclassname">apriltag.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.w">
<code class="descclassname">apriltag.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag边界框的w坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.h">
<code class="descclassname">apriltag.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag边界框的h坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.id">
<code class="descclassname">apriltag.</code><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.id" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag的数字ID。</p>
<blockquote>
<div><ul class="simple">
<li>TAG16H5 -&gt; 0 to 29</li>
<li>TAG25H7 -&gt; 0 to 241</li>
<li>TAG25H9 -&gt; 0 to 34</li>
<li>TAG36H10 -&gt; 0 to 2319</li>
<li>TAG36H11 -&gt; 0 to 586</li>
<li>ARTOOLKIT -&gt; 0 to 511</li>
</ul>
</div></blockquote>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.family">
<code class="descclassname">apriltag.</code><code class="descname">family</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.family" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag的数字家庭。</p>
<blockquote>
<div><ul class="simple">
<li>image.TAG16H5</li>
<li>image.TAG25H7</li>
<li>image.TAG25H9</li>
<li>image.TAG36H10</li>
<li>image.TAG36H11</li>
<li>image.ARTOOLKIT</li>
</ul>
</div></blockquote>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.cx">
<code class="descclassname">apriltag.</code><code class="descname">cx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.cx" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag的中心x位置(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.cy">
<code class="descclassname">apriltag.</code><code class="descname">cy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.cy" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag的中心y位置(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.rotation">
<code class="descclassname">apriltag.</code><code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的AprilTag的旋度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.decision_margin">
<code class="descclassname">apriltag.</code><code class="descname">decision_margin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.decision_margin" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag匹配的色饱和度（取值0.0 - 1.0），其中1.0为最佳。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[9]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.hamming">
<code class="descclassname">apriltag.</code><code class="descname">hamming</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.hamming" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag的可接受的数位误差数值。</p>
<blockquote>
<div><ul class="simple">
<li>TAG16H5 -&gt; 最多可接受0位错误</li>
<li>TAG25H7 -&gt; 最多可接受1位错误</li>
<li>TAG25H9 -&gt; 最多可接受3位错误</li>
<li>TAG36H10 -&gt; 最多可接受3位错误</li>
<li>TAG36H11 -&gt; 最多可接受4位错误</li>
<li>ARTOOLKIT -&gt; 最多可接受0位错误</li>
</ul>
</div></blockquote>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.goodness">
<code class="descclassname">apriltag.</code><code class="descname">goodness</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.goodness" title="永久链接至目标">¶</a></dt>
<dd><p>返回AprilTag图像的色饱和度（取值0.0 - 1.0），其中1.0为最佳。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">目前这一数值通常是0.0。未来我们可以启用一个称为“标签细化”的功能，以实现对更小的AprilTag的检测。然而，现在这个功能将帧速率降低到1 FPS以下。</p>
</div>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[11]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.x_translation">
<code class="descclassname">apriltag.</code><code class="descname">x_translation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.x_translation" title="永久链接至目标">¶</a></dt>
<dd><p>返回距离摄像机x方向的变换，距离的单位未知。</p>
<p>这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响X单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。</p>
<p>注意：此处的方向为从左至右。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[12]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.y_translation">
<code class="descclassname">apriltag.</code><code class="descname">y_translation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.y_translation" title="永久链接至目标">¶</a></dt>
<dd><p>返回距离摄像机y方向的变换，距离的单位未知。</p>
<p>这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Y单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。</p>
<p>注意：此处的方向为从上至下。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[13]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.z_translation">
<code class="descclassname">apriltag.</code><code class="descname">z_translation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.z_translation" title="永久链接至目标">¶</a></dt>
<dd><p>返回距离摄像机z方向的变换，距离的单位未知。</p>
<p>T这个方法对于确定远离摄像机的AprilTag的位置很有用。但是，AprilTag的大小以及您使用的镜头等因素都会影响Z单元归属的确定。为使用方便，我们推荐您使用查找表将该方法的输出转换为对您的应用程序有用的信息。</p>
<p>注意：此处的方向为从前至后。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[14]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.x_rotation">
<code class="descclassname">apriltag.</code><code class="descname">x_rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.x_rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的AprilTag在X平面上的旋度。例：目视AprilTag，从左至右移动摄像头。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[15]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.y_rotation">
<code class="descclassname">apriltag.</code><code class="descname">y_rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.y_rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的AprilTag在Y平面上的旋度。例：目视AprilTag，从上至下移动摄像头。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[16]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="apriltag.z_rotation">
<code class="descclassname">apriltag.</code><code class="descname">z_rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#apriltag.z_rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的AprilTag在Z平面上的旋度。例：目视AprilTag，旋转摄像头。</p>
<p>注意：这只是 <a class="reference internal" href="#apriltag.rotation" title="apriltag.rotation"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">apriltag.rotation()</span></code></a> 的重命名版本。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[17]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="datamatrix">
<h1>DataMatrix类 – 数据矩阵对象<a class="headerlink" href="#datamatrix" title="永久链接至标题">¶</a></h1>
<p>数据矩阵对象是由 <a class="reference internal" href="#image.find_datamatrices" title="image.find_datamatrices"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_datamatrices</span></code></a> 返回的。</p>
<div class="section" id="id26">
<h2>构造函数<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.datamatrix">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">datamatrix</code><a class="headerlink" href="#image.datamatrix" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_datamatrices" title="image.find_datamatrices"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_datamatrices()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id27">
<h2>方法<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="datamatrix.corners">
<code class="descclassname">datamatrix.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.rect">
<code class="descclassname">datamatrix.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 <a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.x">
<code class="descclassname">datamatrix.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.y">
<code class="descclassname">datamatrix.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.w">
<code class="descclassname">datamatrix.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的边界框的w宽度。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.h">
<code class="descclassname">datamatrix.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的边界框的h高度。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.payload">
<code class="descclassname">datamatrix.</code><code class="descname">payload</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.payload" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的有效载荷的字符串。例：字符串。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.rotation">
<code class="descclassname">datamatrix.</code><code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的数据矩阵的旋度(浮点数)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.rows">
<code class="descclassname">datamatrix.</code><code class="descname">rows</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.rows" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的行数(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.columns">
<code class="descclassname">datamatrix.</code><code class="descname">columns</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.columns" title="永久链接至目标">¶</a></dt>
<dd><p>返回数据矩阵的列数(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.capacity">
<code class="descclassname">datamatrix.</code><code class="descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.capacity" title="永久链接至目标">¶</a></dt>
<dd><p>返回这一数据矩阵所能容纳的字符的数量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="datamatrix.padding">
<code class="descclassname">datamatrix.</code><code class="descname">padding</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datamatrix.padding" title="永久链接至目标">¶</a></dt>
<dd><p>返回这一数据矩阵中未使用的字符的数量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[9]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="barcode">
<h1>BarCode类 – 条形码对象<a class="headerlink" href="#barcode" title="永久链接至标题">¶</a></h1>
<p>条形码对象是由 <a class="reference internal" href="#image.find_barcodes" title="image.find_barcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_barcodes</span></code></a> 返回的。</p>
<div class="section" id="id28">
<h2>构造函数<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.barcode">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">barcode</code><a class="headerlink" href="#image.barcode" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_barcodes" title="image.find_barcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_barcodes()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id29">
<h2>方法<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="barcode.corners">
<code class="descclassname">barcode.</code><code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.corners" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个由该对象的四个角组成的四个元组(x,y)的列表。四个角通常是按照从左上角开始沿顺时针顺序返回的。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.rect">
<code class="descclassname">barcode.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如数据矩阵的边界框的 <a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.x">
<code class="descclassname">barcode.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.y">
<code class="descclassname">barcode.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.w">
<code class="descclassname">barcode.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的边界框的w宽度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.h">
<code class="descclassname">barcode.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的边界框的h高度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.payload">
<code class="descclassname">barcode.</code><code class="descname">payload</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.payload" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的有效载荷的字符串。例：数量。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.type">
<code class="descclassname">barcode.</code><code class="descname">type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.type" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码的列举类型 (int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
<blockquote>
<div><ul class="simple">
<li>image.EAN2</li>
<li>image.EAN5</li>
<li>image.EAN8</li>
<li>image.UPCE</li>
<li>image.ISBN10</li>
<li>image.UPCA</li>
<li>image.EAN13</li>
<li>image.ISBN13</li>
<li>image.I25</li>
<li>image.DATABAR</li>
<li>image.DATABAR_EXP</li>
<li>image.CODABAR</li>
<li>image.CODE39</li>
<li>image.PDF417 - 未来启用 (e.g. 现在还不能正常使用).</li>
<li>image.CODE93</li>
<li>image.CODE128</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="barcode.rotation">
<code class="descclassname">barcode.</code><code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回以弧度计的条形码的旋度(浮点数)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="barcode.quality">
<code class="descclassname">barcode.</code><code class="descname">quality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#barcode.quality" title="永久链接至目标">¶</a></dt>
<dd><p>返回条形码在图像中被检测到的次数(int)。</p>
<p>扫描条形码时，每一条新的扫描线都能解码相同的条形码。每次进行这一过程，条形码的值都会随之增加。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="displacement">
<h1>Displacement类 – 位移对象<a class="headerlink" href="#displacement" title="永久链接至标题">¶</a></h1>
<p>位移对象由 <a class="reference internal" href="#image.find_displacement" title="image.find_displacement"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_displacement</span></code></a> 返回。</p>
<div class="section" id="id30">
<h2>构造函数<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.displacement">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">displacement</code><a class="headerlink" href="#image.displacement" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.find_displacement" title="image.find_displacement"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_displacement()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id31">
<h2>方法<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="displacement.x_translation">
<code class="descclassname">displacement.</code><code class="descname">x_translation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#displacement.x_translation" title="永久链接至目标">¶</a></dt>
<dd><p>返回两个图像之间的x平移像素。 这是精确的子像素，所以它是一个浮点数。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="displacement.y_translation">
<code class="descclassname">displacement.</code><code class="descname">y_translation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#displacement.y_translation" title="永久链接至目标">¶</a></dt>
<dd><p>返回两个图像之间的y平移像素。 这是精确的子像素，所以它是一个浮点数。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="displacement.rotation">
<code class="descclassname">displacement.</code><code class="descname">rotation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#displacement.rotation" title="永久链接至目标">¶</a></dt>
<dd><p>返回两个图像之间的z平移像素。 这是精确的子像素，所以它是一个浮点数。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="displacement.scale">
<code class="descclassname">displacement.</code><code class="descname">scale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#displacement.scale" title="永久链接至目标">¶</a></dt>
<dd><p>返回两个图像之间旋转的弧度。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="displacement.response">
<code class="descclassname">displacement.</code><code class="descname">response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#displacement.response" title="永久链接至目标">¶</a></dt>
<dd><p>返回两幅图像之间位移匹配结果的质量。
范围 0-1。响应小于0.1的 <code class="docutils literal notranslate"><span class="pre">displacement</span></code> 对象可能是噪声。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="kptmatch">
<h1>Kptmatch类 – 特征点对象<a class="headerlink" href="#kptmatch" title="永久链接至标题">¶</a></h1>
<p>特征点对象是由 <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor</span></code></a> 返回的。</p>
<div class="section" id="id32">
<h2>构造函数<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.kptmatch">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">kptmatch</code><a class="headerlink" href="#image.kptmatch" title="永久链接至目标">¶</a></dt>
<dd><p>请调用 <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor()</span></code></a> 函数来创建此对象。</p>
</dd></dl>

</div>
<div class="section" id="id33">
<h2>方法<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="kptmatch.rect">
<code class="descclassname">kptmatch.</code><code class="descname">rect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.rect" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个矩形元组(x, y, w, h)，用于如特征点的边界框的 <a class="reference internal" href="#image.draw_rectangle" title="image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.draw_rectangle</span></code></a> 等其他的 <code class="xref any docutils literal notranslate"><span class="pre">image</span></code> 方法。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.cx">
<code class="descclassname">kptmatch.</code><code class="descname">cx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.cx" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点的中心x位置(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[0]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.cy">
<code class="descclassname">kptmatch.</code><code class="descname">cy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.cy" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点的中心y位置(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[1]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.x">
<code class="descclassname">kptmatch.</code><code class="descname">x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.x" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点边界框的x坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[2]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.y">
<code class="descclassname">kptmatch.</code><code class="descname">y</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.y" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点边界框的y坐标(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[3]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.w">
<code class="descclassname">kptmatch.</code><code class="descname">w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.w" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点边界框的w宽度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[4]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.h">
<code class="descclassname">kptmatch.</code><code class="descname">h</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.h" title="永久链接至目标">¶</a></dt>
<dd><p>返回特征点边界框的h高度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[5]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.count">
<code class="descclassname">kptmatch.</code><code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.count" title="永久链接至目标">¶</a></dt>
<dd><p>返回匹配的特征点的数量(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[6]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.theta">
<code class="descclassname">kptmatch.</code><code class="descname">theta</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.theta" title="永久链接至目标">¶</a></dt>
<dd><p>返回估计的特征点的旋度(int)。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[7]</span></code> 取得这个值。</p>
</dd></dl>

<dl class="method">
<dt id="kptmatch.match">
<code class="descclassname">kptmatch.</code><code class="descname">match</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kptmatch.match" title="永久链接至目标">¶</a></dt>
<dd><p>返回匹配关键点的(x，y)元组列表。</p>
<p>您也可以通过索引 <code class="docutils literal notranslate"><span class="pre">[8]</span></code> 取得这个值。</p>
</dd></dl>

</div>
</div>
<div class="section" id="imagewriter-imagewriter">
<h1>ImageWriter类 – ImageWriter对象<a class="headerlink" href="#imagewriter-imagewriter" title="永久链接至标题">¶</a></h1>
<p>ImageWriter对象使得您可以快速地将未压缩的图像写入磁盘。</p>
<div class="section" id="id34">
<h2>构造函数<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.ImageWriter">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">ImageWriter</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageWriter" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个ImageWriter对象，您就可以以用于OpenMV Cams的简单文件格式将未压缩的图像写到磁盘上。然后未压缩的图像可以使用ImageReader重新读取。</p>
</dd></dl>

</div>
<div class="section" id="id35">
<h2>方法<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="imagewriter.size">
<code class="descclassname">imagewriter.</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#imagewriter.size" title="永久链接至目标">¶</a></dt>
<dd><p>返回正在写入的文件的大小。</p>
</dd></dl>

<dl class="method">
<dt id="imagewriter.add_frame">
<code class="descclassname">imagewriter.</code><code class="descname">add_frame</code><span class="sig-paren">(</span><em>img</em><span class="sig-paren">)</span><a class="headerlink" href="#imagewriter.add_frame" title="永久链接至目标">¶</a></dt>
<dd><p>将一张图像写入磁盘。由于图像未被压缩，因此执行迅速，但会占用大量磁盘空间。</p>
</dd></dl>

<dl class="method">
<dt id="imagewriter.close">
<code class="descclassname">imagewriter.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#imagewriter.close" title="永久链接至目标">¶</a></dt>
<dd><p>关闭图像流文件。您必须关闭文件，否则文件会损坏。</p>
</dd></dl>

</div>
</div>
<div class="section" id="imagereader-imagereader">
<h1>ImageReader 类– ImageReader对象<a class="headerlink" href="#imagereader-imagereader" title="永久链接至标题">¶</a></h1>
<p>ImageReader对象使得您可以快速地从磁盘中读取未压缩的图像。</p>
<div class="section" id="id36">
<h2>构造函数<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.ImageReader">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">ImageReader</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageReader" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个ImageReader对象，用来回放由ImageWriter对象编写的图像数据。ImageWriter对象回放的帧会在与写入磁盘时相同的FPS下回放。</p>
</dd></dl>

</div>
<div class="section" id="id37">
<h2>方法<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="imagereader.size">
<code class="descclassname">imagereader.</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#imagereader.size" title="永久链接至目标">¶</a></dt>
<dd><p>返回正在读取的文件的大小。</p>
</dd></dl>

<dl class="method">
<dt id="imagereader.next_frame">
<code class="descclassname">imagereader.</code><code class="descname">next_frame</code><span class="sig-paren">(</span><span class="optional">[</span><em>copy_to_fb=True</em>, <em>loop=True</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#imagereader.next_frame" title="永久链接至目标">¶</a></dt>
<dd><p>从ImageWriter写就的文件中返回图像对象。若 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code>&nbsp;为True，图像对象将被直接加载到帧缓冲区中。否则图像对象将被放入堆中。注意：除非图像很小，否则堆可能没有足够的空间来存储图像对象。
若 <code class="docutils literal notranslate"><span class="pre">loop</span></code> 为True，流的最后一个图像读取之后，回放将重新开始。否则所有帧被读取后，这个方法将返回None。</p>
<p>你也可以将 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖，从而更改传递的图像对象的像素格式和分辨率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为True或另一个图像对象，则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。
由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。</p>
</div>
<p>注意： <a class="reference internal" href="#imagereader.next_frame" title="imagereader.next_frame"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">imagereader.next_frame</span></code></a> 尝试在读取帧后通过暂停播放来限制回放速度，以与帧记录的速度相匹配。
否则，这个方法会以200+FPS的速度图像快读播放所有图像。</p>
</dd></dl>

<dl class="method">
<dt id="imagereader.close">
<code class="descclassname">imagereader.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#imagereader.close" title="永久链接至目标">¶</a></dt>
<dd><p>关闭正在读取的文件。您需要进行这一操作，以防imagereader 对象受损。但由于是只读文件，文件不会在未关闭时受损。</p>
</dd></dl>

</div>
</div>
<div class="section" id="id38">
<h1>Image类 – 图像对象<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h1>
<p>图像对象是机器视觉操作的基本对象。</p>
<div class="section" id="id39">
<h2>构造函数<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h2>
<dl class="class">
<dt id="image.Image">
<em class="property">class </em><code class="descclassname">image.</code><code class="descname">Image</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>copy_to_fb=False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image" title="永久链接至目标">¶</a></dt>
<dd><p>或者，您可以传递一个宽度、高度和 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.BINARY" title="sensor.sensor.BINARY"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.BINARY</span></code></a>, <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a>, 或
<a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 来创建新的空白图像对象(初始化为0 -黑色)。</p>
<p>支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。</p>
<p>若 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code>&nbsp;为True，图像会直接载入帧缓冲区，您就可以加载大幅图片了。若为False，图像会载入MicroPython的堆中，堆远比帧缓冲区小。</p>
<p>你也可以将 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖，
从而更改传递的图像对象的像素格式和分辨率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为True或另一个图像对象，则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。
由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。</p>
</div>
<p>图像支持“[]”记法。 令&nbsp;<code class="docutils literal notranslate"><span class="pre">image[index]&nbsp;=&nbsp;8/16-bit&nbsp;value</span></code> ，以便分配图像像素或 <code class="docutils literal notranslate"><span class="pre">image[index]</span></code> ，并得到一个图像像素，若是用于RGB图像的16位RGB565值的灰度图像，
这一像素则为8位。</p>
<p>对于JPEG图像而言，“[]”使得您可以访问压缩的节数组形式的JPEG图像色块。由于JPEG图像是压缩的字节流形式，因而对数据组的读取和写入是不透明的。</p>
<p>图像还支持读缓冲区操作。您可以把图像当作节数组对象，将图像输入所有类型的MicroPython函数。若您想传送一个图像，可以将它传递给UART /SPI/ I2C写入函数，可实现自动传送。</p>
</dd></dl>

</div>
<div class="section" id="id40">
<h2>方法<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="image.width">
<code class="descclassname">image.</code><code class="descname">width</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.width" title="永久链接至目标">¶</a></dt>
<dd><p>返回以像素计的图像的宽度。</p>
</dd></dl>

<dl class="method">
<dt id="image.height">
<code class="descclassname">image.</code><code class="descname">height</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.height" title="永久链接至目标">¶</a></dt>
<dd><p>返回以像素计的图像的高度。</p>
</dd></dl>

<dl class="method">
<dt id="image.format">
<code class="descclassname">image.</code><code class="descname">format</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.format" title="永久链接至目标">¶</a></dt>
<dd><p>返回用于灰度图的 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> 、用于RGB图像的 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 和用于JPEG图像的 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.JPEG" title="sensor.sensor.JPEG"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.JPEG</span></code></a> 。</p>
</dd></dl>

<dl class="method">
<dt id="image.size">
<code class="descclassname">image.</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.size" title="永久链接至目标">¶</a></dt>
<dd><p>返回以字节计的图像大小。</p>
</dd></dl>

<dl class="method">
<dt id="image.get_pixel">
<code class="descclassname">image.</code><code class="descname">get_pixel</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>rgbtuple</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.get_pixel" title="永久链接至目标">¶</a></dt>
<dd><p>灰度图：返回(x, y)位置的灰度像素值。</p>
<p>RGB565l：返回(x, y)位置的RGB888像素元组(r, g, b)。</p>
<p>Bayer图像: 返回(x, y)位置的像素值。</p>
<p>不支持压缩图像。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="#image.get_pixel" title="image.get_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_pixel()</span></code></a> 和 <a href="#id41"><span class="problematic" id="id42">`</span></a>image.set_pixel()`是允许你操作Bayer模式图像的唯一方法。
Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。
对于奇数行，其中图像中的像素是G/B/G/B/等。
每个像素是8位。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="image.set_pixel">
<code class="descclassname">image.</code><code class="descname">set_pixel</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>pixel</em><span class="sig-paren">)</span><a class="headerlink" href="#image.set_pixel" title="永久链接至目标">¶</a></dt>
<dd><p>灰度图：将(x, y) 位置的像素设置为灰度值 <code class="docutils literal notranslate"><span class="pre">pixel</span></code> 。</p>
<p>RGB图像：将(x, y) 位置的像素设置为RGB888元组(r, g, b)&nbsp;<code class="docutils literal notranslate"><span class="pre">pixel</span></code> 。</p>
<p>不支持压缩图像。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><a class="reference internal" href="#image.get_pixel" title="image.get_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.get_pixel()</span></code></a> 和 <a href="#id43"><span class="problematic" id="id44">`</span></a>image.set_pixel()`是允许你操作Bayer模式图像的唯一方法。
Bayer模式图像是文字图像。对于偶数行，其中图像中的像素是R/G/R/G/等。
对于奇数行，其中图像中的像素是G/B/G/B/等。
每个像素是8位。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="image.mean_pool">
<code class="descclassname">image.</code><code class="descname">mean_pool</code><span class="sig-paren">(</span><em>x_div</em>, <em>y_div</em><span class="sig-paren">)</span><a class="headerlink" href="#image.mean_pool" title="永久链接至目标">¶</a></dt>
<dd><p>在图像中找到 <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> 正方形的平均值，并返回由每个正方形的平均值组成的修改图像。</p>
<p>此方法允许您在原来图像上快速缩小图像。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.mean_pooled">
<code class="descclassname">image.</code><code class="descname">mean_pooled</code><span class="sig-paren">(</span><em>x_div</em>, <em>y_div</em><span class="sig-paren">)</span><a class="headerlink" href="#image.mean_pooled" title="永久链接至目标">¶</a></dt>
<dd><p>在图像中找到 <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> 正方形的平均值，并返回由每个正方形的平均值组成的新图像。</p>
<p>此方法允许您创建缩小的图像副本。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.midpoint_pool">
<code class="descclassname">image.</code><code class="descname">midpoint_pool</code><span class="sig-paren">(</span><em>x_div</em>, <em>y_div</em><span class="optional">[</span>, <em>bias=0.5</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.midpoint_pool" title="永久链接至目标">¶</a></dt>
<dd><p>在图像中找到 <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> 正方形的中点值，并返回由每个正方形的中点值组成的修改图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">bias</span></code> 为0.0返回每个区域的最小值，而``bias`` 为1.0返回每个区域的最大值。</p>
<p>此方法允许您在原来图像上快速缩小图像。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.midpoint_pooled">
<code class="descclassname">image.</code><code class="descname">midpoint_pooled</code><span class="sig-paren">(</span><em>x_div</em>, <em>y_div</em><span class="optional">[</span>, <em>bias=0.5</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.midpoint_pooled" title="永久链接至目标">¶</a></dt>
<dd><p>在图像中找到 <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> 正方形的中点值，并返回由每个正方形的中点值组成的新图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">bias</span></code> 为0.0返回每个区域的最小值，而``bias`` 为1.0返回每个区域的最大值。</p>
<p>此方法允许您创建缩小的图像副本。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.to_bitmap">
<code class="descclassname">image.</code><code class="descname">to_bitmap</code><span class="sig-paren">(</span><span class="optional">[</span><em>copy=False</em><span class="optional">[</span>, <em>rgb_channel=-1</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.to_bitmap" title="永久链接至目标">¶</a></dt>
<dd><p>将图像转换为位图图像(每像素1位)。此方法也会修改底层图像像素，从而更改图像大小（以字节为单位），
因此只能在灰度或RGB565图像上进行。
否则，<code class="docutils literal notranslate"><span class="pre">copy</span></code> 必须为True才能在堆上创建新的修改后的图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> 如果设置为0/1/2，则分别从R/G/B通道创建一个位图，
而如果在RGB565图像上调用此方法，则从RGB565像素计算中心阈值灰度值。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">位图图像就像只有两个像素值（0和1）的灰度图像一样。
此外，位图图像被打包，这样它们每个像素仅存储1位，因此非常小。
OpenMV图像库允许位图图像在所有位置的 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> 和 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 中使用。
但是，将许多操作应用于位图图像时没有任何意义，因为位图图像只有2个值。
OpenMV建议在操作中对 <code class="docutils literal notranslate"><span class="pre">mask</span></code> 值使用位图图像，因为它们很容易适合MicroPython堆。
最后，将位图图像像素值0和1应用于 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> 或 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 图像时，
将被解释为黑白。该库自动处理转换。</p>
</div>
<p>返回图像对象，&nbsp;因此您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.to_grayscale">
<code class="descclassname">image.</code><code class="descname">to_grayscale</code><span class="sig-paren">(</span><span class="optional">[</span><em>copy=False</em><span class="optional">[</span>, <em>rgb_channel=-1</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.to_grayscale" title="永久链接至目标">¶</a></dt>
<dd><p>将图像转换为灰度图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在灰度图像或RGB565图像上进行。
否则 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 必须为True才能在堆上创建新的修改图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> 如果设置为0/1/2，则分别从R/G/B通道创建一个灰度图像，
而如果在RGB565图像上调用此方法，则从RGB565像素计算灰度值。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.to_rgb565">
<code class="descclassname">image.</code><code class="descname">to_rgb565</code><span class="sig-paren">(</span><span class="optional">[</span><em>copy=False</em><span class="optional">[</span>, <em>rgb_channel=-1</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.to_rgb565" title="永久链接至目标">¶</a></dt>
<dd><p>将图像转换为彩色图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。
否则 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 必须为True才能在堆上创建新的修改图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> 如果设置为0/1/2，则分别从R/G/B通道创建RGB565图像(如果对RGB565图像调用此方法)。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.to_rainbow">
<code class="descclassname">image.</code><code class="descname">to_rainbow</code><span class="sig-paren">(</span><span class="optional">[</span><em>copy=False</em><span class="optional">[</span>, <em>rgb_channel=-1</em><span class="optional">[</span>, <em>color_palette=sensor.PALETTE_RAINBOW</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.to_rainbow" title="永久链接至目标">¶</a></dt>
<dd><p>将图像转换为彩虹图像。 此方法也会修改基础图像像素，以字节为单位更改图像大小，因此只能在RGB565图像上进行。
否则 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 必须为True才能在堆上创建新的修改图像。</p>
<p>彩虹图像是彩色图像，对于图像中的每个8位掩模灰度照明值具有唯一的颜色值。 例如，它为热图像提供热图颜色。</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> 如果设置为0/1/2，则分别从R/G/B通道创建彩虹图像(如果在RGB565图像上调用此方法)。</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> 设置用于彩虹转换的调色板。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.compress">
<code class="descclassname">image.</code><code class="descname">compress</code><span class="sig-paren">(</span><span class="optional">[</span><em>quality=50</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.compress" title="永久链接至目标">¶</a></dt>
<dd><p>JPEG对图像进行适当压缩。使用这种方法与 <code class="docutils literal notranslate"><span class="pre">compressed</span></code> 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> 是压缩质量（0-100）（int）。</p>
</dd></dl>

<dl class="method">
<dt id="image.compress_for_ide">
<code class="descclassname">image.</code><code class="descname">compress_for_ide</code><span class="sig-paren">(</span><span class="optional">[</span><em>quality=50</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.compress_for_ide" title="永久链接至目标">¶</a></dt>
<dd><p>JPEG对图像进行适当压缩。使用这种方法与 <code class="docutils literal notranslate"><span class="pre">compressed</span></code> 保存堆空间相比，使用更高quality的压缩率是以破坏原始图像为代价的。</p>
<p>这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。</p>
<p>您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> 是压缩质量（0-100）（int）。</p>
</dd></dl>

<dl class="method">
<dt id="image.compressed">
<code class="descclassname">image.</code><code class="descname">compressed</code><span class="sig-paren">(</span><span class="optional">[</span><em>quality=50</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.compressed" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> 是压缩质量（0-100）（int）。</p>
</dd></dl>

<dl class="method">
<dt id="image.compressed_for_ide">
<code class="descclassname">image.</code><code class="descname">compressed_for_ide</code><span class="sig-paren">(</span><span class="optional">[</span><em>quality=50</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.compressed_for_ide" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个JPEG压缩图像—原始图像未经处理。但是，这个方法需要堆空间的大分配，所以图像压缩质量和图像分辨率必须很低。</p>
<p>这个方法压缩图像，然后通过将每6比特编码为128 - 191之间的字节将JPEG数据格式化，转换为OpenMV IDE，以便显示。进行这一步是为防止JPEG数据被误认为是字节流中的其他文本数据。</p>
<p>您需要使用这一方法来格式化图像数据，以便在OpenMV IDE中通过“开放终端”创建的终端窗口中显示。</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> 是压缩质量（0-100）（int）。</p>
</dd></dl>

<dl class="method">
<dt id="image.jpeg_encode_for_ide">
<code class="descclassname">image.</code><code class="descname">jpeg_encode_for_ide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.jpeg_encode_for_ide" title="永久链接至目标">¶</a></dt>
<dd><p>通过将每6位编码为一个介于128-191之间的字节，此格式将JPEG数据格式化以传输到OpenMV IDE进行显示。
这样做是为了防止将JPEG数据误解为字节流中的其他文本数据。
此方法进行原位格式化会破坏原始JPEG图像，并返回编码的jpeg图像。</p>
<p>您需要使用此方法将图像数据格式化，以便显示到通过OpenMV IDE中的”Open Terminal打开终端”创建的终端窗口。</p>
<p>返回图像对象，因此您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>只适用于JPEG图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.copy">
<code class="descclassname">image.</code><code class="descname">copy</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>x_scale</em><span class="optional">[</span>, <em>y_scale</em><span class="optional">[</span>, <em>copy_to_fb=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.copy" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个图像对象的副本。</p>
<p><code class="docutils literal notranslate"><span class="pre">Roi</span></code>&nbsp;是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> 是一个浮点值，通过它可以在x方向上缩放图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> 是一个浮点值，通过它可以在y方向上缩放图像。</p>
<p>请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。 因此，复制图像很容易导致RAM不足。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。</p>
<p>你也可以将 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖，
从而更改传递的图像对象的像素格式和分辨率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果``copy_to_fb``设置为True或另一个图像对象, 则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。
由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。</p>
</div>
<p>返回新的图像对象。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.crop">
<code class="descclassname">image.</code><code class="descname">crop</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>x_scale</em><span class="optional">[</span>, <em>y_scale</em><span class="optional">[</span>, <em>copy_to_fb=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.crop" title="永久链接至目标">¶</a></dt>
<dd><p>类似 <code class="docutils literal notranslate"><span class="pre">image.copy()</span></code>，但它对image对象进行操作，而不是进行深度复制。</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是要从中复制的感兴趣区域矩形(x, y, w, h)。
如果没有指定，它等于复制整个图像的图像矩形。此参数不适用于JPEG图像。</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> 是一个浮点值，通过它可以在x方向上缩放图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> 是一个浮点值，通过它可以在y方向上缩放图像。</p>
<p>请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。 因此，复制图像很容易导致RAM不足。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。</p>
<p>你也可以将 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖，
从而更改传递的图像对象的像素格式和分辨率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果``copy_to_fb``设置为True或另一个图像对象, 则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。
由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。</p>
</div>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.scale">
<code class="descclassname">image.</code><code class="descname">scale</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>x_scale</em><span class="optional">[</span>, <em>y_scale</em><span class="optional">[</span>, <em>copy_to_fb=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.scale" title="永久链接至目标">¶</a></dt>
<dd><p>类似 <code class="docutils literal notranslate"><span class="pre">image.copy()</span></code>，但它对image对象进行操作，而不是进行深度复制。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是要从中复制的感兴趣区域矩形(x, y, w, h)。
如果没有指定，它等于复制整个图像的图像矩形。此参数不适用于JPEG图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> 是一个浮点值，通过它可以在x方向上缩放图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> 是一个浮点值，通过它可以在y方向上缩放图像。</p>
<p>请记住图像副本储存在MicroPython 堆中而不是帧缓冲区。 因此，复制图像很容易导致RAM不足。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 为True，则该方法将帧缓冲替换为图像。 帧缓冲区具有比堆大得多的空间，并且可以容纳大图像。</p>
<p>你也可以将 <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> 设置为另一个图像对象，然后该缓冲区将被复制的图像覆盖，
从而更改传递的图像对象的像素格式和分辨率。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果``copy_to_fb``设置为True或另一个图像对象, 则不继续使用传递给这个方法的旧图像对象或帧缓冲区图像对象。
由于此旧参考现在已过时，请使用此方法返回的新图像对象参考。</p>
</div>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.save">
<code class="descclassname">image.</code><code class="descname">save</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>quality=50</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.save" title="永久链接至目标">¶</a></dt>
<dd><p>将图像的副本保存到 <code class="docutils literal notranslate"><span class="pre">path</span></code> 中的文件系统。</p>
<p>支持bmp/pgm/ppm/jpg/jpeg格式的图像文件。注意：您无法将jpeg格式的压缩图像保存成未压缩的格式。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code>&nbsp;是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即复制整个图像的图像矩形。但这不适用于JPEG图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code>&nbsp;指在图像尚未被压缩时将图像保存为JPEG格式的JPEG压缩质量。</p>
</dd></dl>

<dl class="method">
<dt id="image.clear">
<code class="descclassname">image.</code><code class="descname">clear</code><span class="sig-paren">(</span><span class="optional">[</span><em>mask</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.clear" title="永久链接至目标">¶</a></dt>
<dd><p>将图像中的所有像素设置为零（非常快）。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_line">
<code class="descclassname">image.</code><code class="descname">draw_line</code><span class="sig-paren">(</span><em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_line" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制一条从(x0，y0)到(x1，y1)的线。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线的粗细像素。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_rectangle">
<code class="descclassname">image.</code><code class="descname">draw_rectangle</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>w</em>, <em>h</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">[</span>, <em>fill=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_rectangle" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制一个矩形。 您可以单独传递x，y，w，h或作为元组(x，y，w，h)传递。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线的粗细像素。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">fill</span></code> 设置为True以填充矩形。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_circle">
<code class="descclassname">image.</code><code class="descname">draw_circle</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>radius</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">[</span>, <em>fill=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_circle" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制一个圆形。 您可以单独传递x，y，半径 或 作为元组(x，y，radius)传递。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线的粗细像素。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">fill</span></code> 设置为True以填充圆形。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_ellipse">
<code class="descclassname">image.</code><code class="descname">draw_ellipse</code><span class="sig-paren">(</span><em>cx</em>, <em>cy</em>, <em>rx</em>, <em>ry</em>, <em>rotation</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">[</span>, <em>fill=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_ellipse" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制椭圆。您可以单独传递cx、cy、rx、ry和rotation(以度为单位)，也可以作为元组传递(cx、yc、rx、ry、rotation)。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。
但是，您也可以为灰度图像传递基础像素值(0-255)，或者为RGB565图像传递字节反转的RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制边缘的厚度，以像素为单位。</p>
<p>传递 <code class="docutils literal notranslate"><span class="pre">fill</span></code> 设置为True来填充椭圆。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_string">
<code class="descclassname">image.</code><code class="descname">draw_string</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>text</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>scale=1</em><span class="optional">[</span>, <em>x_spacing=0</em><span class="optional">[</span>, <em>y_spacing=0</em><span class="optional">[</span>, <em>mono_space=True</em><span class="optional">[</span>, <em>char_rotation=0</em><span class="optional">[</span>, <em>char_hmirror=False</em><span class="optional">[</span>, <em>char_vflip=False</em><span class="optional">[</span>, <em>string_rotation=0</em><span class="optional">[</span>, <em>string_hmirror=False</em><span class="optional">[</span>, <em>string_vflip=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_string" title="永久链接至目标">¶</a></dt>
<dd><p>从图像中的(x, y)位置开始绘制8x10文本。您可以单独传递x，y，也可以作为元组(x，y)传递。</p>
<p><code class="docutils literal notranslate"><span class="pre">text</span></code> 是写入图像的字符串。 <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>
结束符将光标移至下一行。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">scale</span></code> 可以放大/缩小图像上文本的大小。您可以传递大于0的整数或浮点值。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_spacing</span></code> 允许你在字符之间添加（如果是正数）或减去（如果是负数）x像素，设置字符间距。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_spacing</span></code> 允许你在字符之间添加（如果是正数）或减去（如果是负数）y像素，设置行间距。</p>
<p><code class="docutils literal notranslate"><span class="pre">mono_space</span></code> 默认为True，强制文本间距固定。对于大文本，这看起来很糟糕。设置False以获得非固定宽度的字符间距，看起来好多了。</p>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a>char_rotation``可以是0、90、180、270，来旋转字符串中的每个字符。</p>
<p><code class="docutils literal notranslate"><span class="pre">char_hmirror</span></code> 如果为True，则水平镜像字符串中的所有字符。</p>
<p><code class="docutils literal notranslate"><span class="pre">char_vflip</span></code> 如果为True，则垂直翻转字符串中的所有字符。</p>
<p><code class="docutils literal notranslate"><span class="pre">string_rotation</span></code> 可以是0、90、180、270，来旋转字符串。</p>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a>string_hmirror``如果为True，则水平镜像字符串。</p>
<p><code class="docutils literal notranslate"><span class="pre">string_vflip</span></code> 如果为True，则垂直翻转字符串。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_cross">
<code class="descclassname">image.</code><code class="descname">draw_cross</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>size=5</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_cross" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制一个十字。 您可以单独传递x，y或作为元组(x，y)传递。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 控制十字线的延伸长度。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制边缘的像素厚度。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_arrow">
<code class="descclassname">image.</code><code class="descname">draw_arrow</code><span class="sig-paren">(</span><em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_arrow" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制一条从(x0，y0)到(x1，y1)的箭头。 您可以单独传递x0，y0，x1，y1，也可以传递给元组(x0，y0，x1，y1)。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，
您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线的粗细像素。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_edges">
<code class="descclassname">image.</code><code class="descname">draw_edges</code><span class="sig-paren">(</span><em>image</em>, <em>corners</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>size=0</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">[</span>, <em>fill=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_edges" title="永久链接至目标">¶</a></dt>
<dd><p>在由 <a class="reference internal" href="#blob.corners" title="blob.corners"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.corners</span></code></a> 等方法返回的角列表之间绘制线边。
Coners是两个x/y元组的四值元组。
例如:[(x1, y1), (x2, y2), (x3, y3), (x4、y4)]。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。
但是，您也可以为灰度图像传递基础像素值(0-255)，或者为RGB565图像传递字节反转的RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 如果大于0，则会将角绘制为半径为 <code class="docutils literal notranslate"><span class="pre">size</span></code> 的圆。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线条的粗细(以像素为单位)。</p>
<p>通过将 <code class="docutils literal notranslate"><span class="pre">fill</span></code> 设置为True来填充绘制的角圆。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_image">
<code class="descclassname">image.</code><code class="descname">draw_image</code><span class="sig-paren">(</span><em>image</em>, <em>x</em>, <em>y</em><span class="optional">[</span>, <em>x_scale=1.0</em><span class="optional">[</span>, <em>y_scale=1.0</em><span class="optional">[</span>, <em>alpha=256</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_image" title="永久链接至目标">¶</a></dt>
<dd><p>绘制一个 <code class="docutils literal notranslate"><span class="pre">image</span></code> ，其左上角从位置x，y开始。 您可以单独传递x，y，也可以传递给元组(x，y)。</p>
<p>这种方法非常灵活，不需要在目标图像上绘制的图像具有相同的宽度/高度/或像素格式(灰度/RGB565)。
该方法还可以自动处理从目标图像边缘绘制的裁剪像素。</p>
<p>也就是说，上述灵活性是伴随着增加绘制时间的成本而来的。
使用更受限的方法，如 <a class="reference internal" href="#image.replace" title="image.replace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.replace</span></code></a> ,
该方法要求两个图像都具有相同的宽度/高度，并使用蒙版，以在需要更高性能时更快地将一个图像渲染到另一个图像上。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> 控制绘制的图像在x方向的缩放(浮点数)。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> 控制绘制的图像在y方向的缩放(浮点数)。</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> 控制另一幅图像与这幅图像的混合程度。
<code class="docutils literal notranslate"><span class="pre">alpha</span></code> 应该是0到256之间的一个整数值。接近零的值会将更多其他图像混合到该图像中，而接近256的值则相反。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
您可以使用mask掩码进行绘制操作。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.draw_keypoints">
<code class="descclassname">image.</code><code class="descname">draw_keypoints</code><span class="sig-paren">(</span><em>keypoints</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>size=10</em><span class="optional">[</span>, <em>thickness=1</em><span class="optional">[</span>, <em>fill=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.draw_keypoints" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上绘制关键点对象的关键点。您还可以传递包含(x, y, rotation_angle_in_degrees)三个值元组的列表，
以重新使用此方法来绘制关键点字形，这些关键字形是具有指向特定方向的线的圆。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 控制特征点的大小。</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> 控制线的粗细像素。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">fill</span></code> 设置为True以填充特征点。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.flood_fill">
<code class="descclassname">image.</code><code class="descname">flood_fill</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>seed_threshold=0.05</em><span class="optional">[</span>, <em>floating_threshold=0.05</em><span class="optional">[</span>, <em>color</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>clear_background=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.flood_fill" title="永久链接至目标">¶</a></dt>
<dd><p>从位置x，y开始填充图像的区域。 您可以单独传递x，y，也可以传递给元组(x，y)。</p>
<p><code class="docutils literal notranslate"><span class="pre">seed_threshold</span></code> 控制填充区域中的像素与原始起始像素的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">floating_threshold</span></code> 控制填充区域中的像素与任何相邻像素的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> 是用于灰度或RGB565图像的RGB888元组。默认为白色。但是，您也可以传递灰度图像的基础像素值(0-255)或RGB565图像的字节反转RGB565值。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 传递为True，以重新填充flood_fill连接区域外的所有内容。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">clear_background</span></code> 传递为True，将其余的flood_fill没有重新着色的像素归零。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩膜中设置的像素会在flood_fill时被评估。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.mask_rectange">
<code class="descclassname">image.</code><code class="descname">mask_rectange</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>w</em>, <em>h</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.mask_rectange" title="永久链接至目标">¶</a></dt>
<dd><p>将图像的矩形部分归零。如果未提供任何参数，则此方法会将图像的中心归零。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.mask_circle">
<code class="descclassname">image.</code><code class="descname">mask_circle</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>radius</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.mask_circle" title="永久链接至目标">¶</a></dt>
<dd><p>将图像的圆形部分归零。如果没有提供参数，则此方法将使图像的中心为零。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.mask_ellipse">
<code class="descclassname">image.</code><code class="descname">mask_ellipse</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em>, <em>y</em>, <em>radius_x</em>, <em>radius_y</em>, <em>rotation_angle_in_degrees</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.mask_ellipse" title="永久链接至目标">¶</a></dt>
<dd><p>将图像的椭圆部分归零。如果没有提供参数，则此方法将使图像的中心为零。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.binary">
<code class="descclassname">image.</code><code class="descname">binary</code><span class="sig-paren">(</span><em>thresholds</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>zero=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">[</span>, <em>to_bitmap=False</em><span class="optional">[</span>, <em>copy=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.binary" title="永久链接至目标">¶</a></dt>
<dd><p>根据像素是否在阈值列表 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 中的阈值内，将图像中的所有像素设置为黑色或白色。</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 必须是元组列表。
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> 定义你想追踪的颜色范围。
对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。
对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。
为方便使用，此功能将自动修复交换的最小值和最大值。
此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。
直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。
这些将是 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 的低值和高值。
由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
<p class="last">您还可以通过进入OpenMV IDE中的 <code class="docutils literal notranslate"><span class="pre">工具</span> <span class="pre">-&gt;机器视觉</span> <span class="pre">-&gt;阈值编辑器</span></code> 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</p>
<p>设置 <code class="docutils literal notranslate"><span class="pre">zero</span></code> 为True来使阈值像素为零，并使不在阈值列表中的像素保持不变。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p><code class="docutils literal notranslate"><span class="pre">to_bitmap</span></code> 将图像数据转换为二进制位图图像，每个像素以1位的形式存储。
对于非常小的图像，新的位图图像可能无法放入原始图像中，因此需要使用 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 进行就地操作。</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> 如果为True，则在堆上创建二进制图像的副本，而不是修改源图像。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">位图图像就像只有两个像素值（0和1）的灰度图像一样。
此外，位图图像被打包，这样它们每个像素仅存储1位，因此非常小。
OpenMV图像库允许位图图像在所有位置的 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> 和 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 中使用。
但是，将许多操作应用于位图图像时没有任何意义，因为位图图像只有2个值。
OpenMV建议在操作中对 <code class="docutils literal notranslate"><span class="pre">mask</span></code> 值使用位图图像，因为它们很容易适合MicroPython堆。
最后，将位图图像像素值0和1应用于 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.GRAYSCALE" title="sensor.sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> 或 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.RGB565" title="sensor.sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> 图像时，
将被解释为黑白。该库自动处理转换。</p>
</div>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.invert">
<code class="descclassname">image.</code><code class="descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.invert" title="永久链接至目标">¶</a></dt>
<dd><p>将二进制图像0（黑色）变为1（白色），1（白色）变为0（黑色），非常快速地翻转二进制图像中的所有像素值。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和Bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_and">
<code class="descclassname">image.</code><code class="descname">b_and</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_and" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑与运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_nand">
<code class="descclassname">image.</code><code class="descname">b_nand</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_nand" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑与非运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_or">
<code class="descclassname">image.</code><code class="descname">b_or</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_or" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑或运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_nor">
<code class="descclassname">image.</code><code class="descname">b_nor</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_nor" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑或非运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_xor">
<code class="descclassname">image.</code><code class="descname">b_xor</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_xor" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑异或运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.b_xnor">
<code class="descclassname">image.</code><code class="descname">b_xnor</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.b_xnor" title="永久链接至目标">¶</a></dt>
<dd><p>用另一图像与这一图像进行逻辑同或运算。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.erode">
<code class="descclassname">image.</code><code class="descname">erode</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.erode" title="永久链接至目标">¶</a></dt>
<dd><p>从分割区域的边缘删除像素。</p>
<p>这一方法通过卷积图像上((size*2)+1)x((size*2)+1)像素的核来实现，如果相邻像素集的总和小于 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> ，则对内核的中心像素进行归零。</p>
<p>若 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.dilate">
<code class="descclassname">image.</code><code class="descname">dilate</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.dilate" title="永久链接至目标">¶</a></dt>
<dd><p>将像素添加到分割区域的边缘中。</p>
<p>这一方法通过卷积图像上((size*2)+1)x((size*2)+1)像素的核来实现，如果相邻像素集的总和大于 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> ，则将内核的中心像素进行设置。</p>
<p>若 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 未设定，这个方法的功能如标准腐蚀方法一样。若threshold设定，您就可以指定腐蚀的特定像素，例如：设置低于2个的像素周围阈值为2。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.open">
<code class="descclassname">image.</code><code class="descname">open</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.open" title="永久链接至目标">¶</a></dt>
<dd><p>按顺序对图像执行腐蚀和膨胀。有关更多信息，请参阅 <a class="reference internal" href="#image.erode" title="image.erode"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.erode()</span></code></a> 和 <a class="reference internal" href="#image.dilate" title="image.dilate"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.dilate()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.close">
<code class="descclassname">image.</code><code class="descname">close</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.close" title="永久链接至目标">¶</a></dt>
<dd><p>按顺序对图像执行膨胀和腐蚀。有关更多信息，请参阅 <a class="reference internal" href="#image.erode" title="image.erode"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.erode()</span></code></a> 和 <a class="reference internal" href="#image.dilate" title="image.dilate"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.dilate()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.top_hat">
<code class="descclassname">image.</code><code class="descname">top_hat</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.top_hat" title="永久链接至目标">¶</a></dt>
<dd><p>返回原图像和执行 <a class="reference internal" href="#image.open" title="image.open"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.open()</span></code></a> 函数后图像的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.black_hat">
<code class="descclassname">image.</code><code class="descname">black_hat</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.black_hat" title="永久链接至目标">¶</a></dt>
<dd><p>返回原图像和执行 <a class="reference internal" href="#image.close" title="image.close"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.close()</span></code></a> 函数后图像的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.gamma_corr">
<code class="descclassname">image.</code><code class="descname">gamma_corr</code><span class="sig-paren">(</span><em>[gamma=1.0, [contrast=1.0, [brightness=0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#image.gamma_corr" title="永久链接至目标">¶</a></dt>
<dd><p>快速改变图像的伽马、对比度和亮度。请用这个方法代替 <a class="reference internal" href="#image.mul" title="image.mul"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.mul</span></code></a> 或 <a class="reference internal" href="#image.div" title="image.div"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.div</span></code></a> 用于混合以调整像素值。</p>
<p><code class="docutils literal notranslate"><span class="pre">gamma</span></code> 值如果大于1.0，那么图像以非线性方式变暗；而小于1.0则使图像变亮。通过将所有像素的颜色通道缩放到[0:1)之间，
然后在缩小之前在所有像素上重新映射 <code class="docutils literal notranslate"><span class="pre">pow(pixel,</span> <span class="pre">1/gamma)</span></code>，将gamma值应用于图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">contrast``值大于1.0，则图像以线性方式变亮；值小于1.0则使图像变暗。通过将所有像素的颜色通道缩放到[0:1)之间，</span>
<span class="pre">然后在缩小之前对所有像素重新映射</span> <span class="pre">``pixel</span> <span class="pre">*</span> <span class="pre">contrast</span></code> ，将对比度值应用于图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">brightness``值大于0.0将使图像以恒定的方式变亮，而小于0.0将使图像变暗。将所有像素的颜色通道缩放到[0:1)之间，</span>
<span class="pre">然后在缩小之前对所有像素重新映射``pixel</span> <span class="pre">+</span> <span class="pre">brightness</span></code> ，将亮度值应用到图像上。</p>
<p>返回图像对象，因此可以使用``.``符号调用另一个方法。</p>
<p>不支持压缩图像或bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.negate">
<code class="descclassname">image.</code><code class="descname">negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.negate" title="永久链接至目标">¶</a></dt>
<dd><p>快速翻转(数值反转)图像中的所有像素值。例如，对于灰度图像，该方法将所有像素从 <code class="docutils literal notranslate"><span class="pre">pixel</span></code> 更改为 <code class="docutils literal notranslate"><span class="pre">255</span> <span class="pre">-</span> <span class="pre">pixel</span></code> 。</p>
<p>非常快速地翻转（数字反转）图像中的所有像素值。对每个颜色通道的像素值进行数值转换。例： (255 - pixel).</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.replace">
<code class="descclassname">image.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>hmirror=False</em><span class="optional">[</span>, <em>vflip=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.replace" title="永久链接至目标">¶</a></dt>
<dd><blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是另一个图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">hmirror</span></code> 设置为True以水平镜像替换图像。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">vflip</span></code> 设置为True以垂直翻转替换图像。</p>
<p>设置``transpose`` 为True，沿对角线翻转图像(如果图像是非正方形，这将改变图像的宽度/高度)。</p>
<p>如果要将图像旋转90度的倍数，请执行以下操作：</p>
<blockquote>
<div><ul class="simple">
<li>vflip=False, hmirror=False, transpose=False -&gt; 0 degree rotation</li>
<li>vflip=True,  hmirror=False, transpose=True  -&gt; 90 degree rotation</li>
<li>vflip=True,  hmirror=True,  transpose=False -&gt; 180 degree rotation</li>
<li>vflip=False, hmirror=True,  transpose=True  -&gt; 270 degree rotation</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果你没有传递一个 <code class="docutils literal notranslate"><span class="pre">image</span></code> ，则该方法将对要替换的基础图像起作用，方法是应用 <code class="docutils literal notranslate"><span class="pre">hmirror</span></code>,
<code class="docutils literal notranslate"><span class="pre">vflip</span></code>, <code class="docutils literal notranslate"><span class="pre">transpose</span></code> 选项进行旋转周围的图像。例如:如果你想执行 <code class="docutils literal notranslate"><span class="pre">img.replace(img,</span> <span class="pre">etc...)</span></code>
你只需要做 <code class="docutils literal notranslate"><span class="pre">img.replace(etc..)</span></code>。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。
请注意，在hmirror/vflip/transpose之前将蒙版应用到图像上，因此该蒙版应与初始未修改图像的宽度/高度相同。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
</div></blockquote>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.assign">
<code class="descclassname">image.</code><code class="descname">assign</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>hmirror=False</em><span class="optional">[</span>, <em>vflip=False</em><span class="optional">[</span>, <em>transpose=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.assign" title="永久链接至目标">¶</a></dt>
<dd><p>别名 <a class="reference internal" href="#image.replace" title="image.replace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.replace</span></code></a> 。</p>
</dd></dl>

<dl class="method">
<dt id="image.set">
<code class="descclassname">image.</code><code class="descname">set</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>hmirror=False</em><span class="optional">[</span>, <em>vflip=False</em><span class="optional">[</span>, <em>transpose=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.set" title="永久链接至目标">¶</a></dt>
<dd><p>别名 <a class="reference internal" href="#image.replace" title="image.replace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.replace</span></code></a> 。</p>
</dd></dl>

<dl class="method">
<dt id="image.add">
<code class="descclassname">image.</code><code class="descname">add</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.add" title="永久链接至目标">¶</a></dt>
<dd><p>将两个图像彼此按像素相加。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.sub">
<code class="descclassname">image.</code><code class="descname">sub</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>reverse=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.sub" title="永久链接至目标">¶</a></dt>
<dd><p>将两个图像彼此按像素相减。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">reverse</span></code> 设置为True可以将减法操作从 <code class="docutils literal notranslate"><span class="pre">this_image-image</span></code>
反转为 <code class="docutils literal notranslate"><span class="pre">image-this_image</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.mul">
<code class="descclassname">image.</code><code class="descname">mul</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.mul" title="永久链接至目标">¶</a></dt>
<dd><p>将两个图像彼此按像素相乘。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 设置为True可将乘法运算从 <code class="docutils literal notranslate"><span class="pre">a*b</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">1/((1/a)*(1/b))</span></code>。
特别是，这使图像变亮而不是使图像变暗(例如，乘法与刻录操作)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.div">
<code class="descclassname">image.</code><code class="descname">div</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.div" title="永久链接至目标">¶</a></dt>
<dd><p>将此图像除以另一个图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p>将 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 设置为True可将除法方向从 <code class="docutils literal notranslate"><span class="pre">a/b</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">b/a</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.min">
<code class="descclassname">image.</code><code class="descname">min</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.min" title="永久链接至目标">¶</a></dt>
<dd><p>在像素级 用此图像和另一个图像之间的最小像素值替换此图像中的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>这个方法在OpenMV4上不可用.</p>
</dd></dl>

<dl class="method">
<dt id="image.max">
<code class="descclassname">image.</code><code class="descname">max</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.max" title="永久链接至目标">¶</a></dt>
<dd><p>在像素级 用此图像和另一个图像之间的最大像素值替换此图像中的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.difference">
<code class="descclassname">image.</code><code class="descname">difference</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.difference" title="永久链接至目标">¶</a></dt>
<dd><p>将两个图像彼此按像素取绝对值。例：对于每个颜色通道而言，将每个像素替换为ABS(this.pixel-image.pixel)。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.blend">
<code class="descclassname">image.</code><code class="descname">blend</code><span class="sig-paren">(</span><em>image</em><span class="optional">[</span>, <em>alpha=128</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blend" title="永久链接至目标">¶</a></dt>
<dd><p>将另外一张图像 <code class="docutils literal notranslate"><span class="pre">image</span></code> 与这一图像融合。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> 控制要混合到这个图像中的其他图像的多少.
<code class="docutils literal notranslate"><span class="pre">alpha</span></code> 应该是0到256之间的整数值。接近零的值会将更多其他图像混合到此图像中，接近256则相反。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.histeq">
<code class="descclassname">image.</code><code class="descname">histeq</code><span class="sig-paren">(</span><span class="optional">[</span><em>adaptive=False</em><span class="optional">[</span>, <em>clip_limit=-1</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histeq" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上运行直方图均衡算法。 直方图均衡化使图像中的对比度和亮度标准化。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">adaptive</span></code> 传递为True，那么将在图像上运行自适应直方图均衡方法，这通常比非自适应直方图限定更好，但运行时间更长。</p>
<p><code class="docutils literal notranslate"><span class="pre">clip_limit</span></code> 提供了一种限制自适应直方图均衡的对比度的方法。
使用较小的值(例如10)可以生成良好的直方图均衡对比度受限图像。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.mean">
<code class="descclassname">image.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>size, [threshold=False, [offset=0, [invert=False, [mask=None]]]]]</em><span class="sig-paren">)</span><a class="headerlink" href="#image.mean" title="永久链接至目标">¶</a></dt>
<dd><p>使用盒式滤波器的标准均值模糊滤波。</p>
<p><code class="docutils literal notranslate"><span class="pre">Size</span></code>&nbsp;是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="median">
<code class="descname">median</code><span class="sig-paren">(</span><em>size, percentile=0.5, threshold=False, offset=0, invert=False, mask]</em><span class="sig-paren">)</span><a class="headerlink" href="#median" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上运行中值滤波。在保留边缘的条件下，中值滤波是用来平滑表面的最佳滤波，但是运行速度极慢。</p>
<p><code class="docutils literal notranslate"><span class="pre">Size</span></code>&nbsp;是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p><code class="docutils literal notranslate"><span class="pre">percentile</span></code>&nbsp;控制内核中所使用值的百分位数。默认情况下，每个像素都使用相邻的第五十个百分位数（中心）替换。使用最小滤波时，您可将此值设置为0，使用下四分位数滤波时设置为0.25，使用上四分位数滤波时设置为0.75，使用最大滤波时设置为1。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.mode">
<code class="descclassname">image.</code><code class="descname">mode</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>threshold=False</em>, <em>offset=0</em>, <em>invert=False</em>, <em>mask</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.mode" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上运行众数滤波，用相邻像素的模式替换每个像素。这一方法在灰度图上运行效果良好。但由于这一操作的非线性特性，会在RGB图像边缘上产生许多伪像。</p>
<p><code class="docutils literal notranslate"><span class="pre">Size</span></code>&nbsp;是内核的大小。取1 (3x3 内核)、2 (5x5 内核)。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.midpoint">
<code class="descclassname">image.</code><code class="descname">midpoint</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>bias=0.5</em>, <em>threshold=False</em>, <em>offset=0</em>, <em>invert=False</em>, <em>mask</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.midpoint" title="永久链接至目标">¶</a></dt>
<dd><p>在图像上运行中点滤波。此滤波器找到图像中每个像素邻域的中点((max-min)/2)。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p><code class="docutils literal notranslate"><span class="pre">bias</span></code> 控制图像混合的最小/最大程度。0只适用于最小滤波，1仅用于最大滤波。您可以通过 <code class="docutils literal notranslate"><span class="pre">bias</span></code> 对图像进行最小/最大化过滤。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.morph">
<code class="descclassname">image.</code><code class="descname">morph</code><span class="sig-paren">(</span><em>size</em>, <em>kernel</em><span class="optional">[</span>, <em>mul</em><span class="optional">[</span>, <em>add=0</em><span class="optional">[</span>, <em>threshold=False</em><span class="optional">[</span>, <em>offset=0</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.morph" title="永久链接至目标">¶</a></dt>
<dd><p>通过过滤器内核对图像进行卷积。这允许您对图像执行通用卷积。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 将内核的大小控制为((size*2)+1)x((size*2)+1)像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">kernel</span></code> 用来卷积图像的内核，可为一个元组或一个取值[-128:127]的列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> 是用来与每个像素卷积结果相加的数值。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 可进行全局对比度调整，add可进行全局亮度调整。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.gaussian">
<code class="descclassname">image.</code><code class="descname">gaussian</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>unsharp=False</em><span class="optional">[</span>, <em>mul</em><span class="optional">[</span>, <em>add=0</em><span class="optional">[</span>, <em>threshold=False</em><span class="optional">[</span>, <em>offset=0</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.gaussian" title="永久链接至目标">¶</a></dt>
<dd><p>通过平滑高斯核对图像进行卷积。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">unsharp</span></code> 设置为True，那么这种方法不会仅进行高斯滤波操作，而是执行非锐化掩模操作，从而提高边缘的图像清晰度。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> 是用来与每个像素卷积结果相加的数值。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 可进行全局对比度调整，add可进行全局亮度调整。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.laplacian">
<code class="descclassname">image.</code><code class="descname">laplacian</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>sharpen=False</em><span class="optional">[</span>, <em>mul</em><span class="optional">[</span>, <em>add=0</em><span class="optional">[</span>, <em>threshold=False</em><span class="optional">[</span>, <em>offset=0</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.laplacian" title="永久链接至目标">¶</a></dt>
<dd><p>通过边缘检测拉普拉斯核来对图像进行卷积。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">sharpen</span></code> 被设置为True，那么这种方法将改为锐化图像，而不是仅输出未经过阈值处理的边缘检测图像。 增加内核大小然后增加图像清晰度。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 是用以与卷积像素结果相乘的数字。若不设置，则默认一个值，该值将防止卷积输出中的缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> 是用来与每个像素卷积结果相加的数值。</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> 可进行全局对比度调整，add可进行全局亮度调整。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.bilateral">
<code class="descclassname">image.</code><code class="descname">bilateral</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>color_sigma=0.1</em><span class="optional">[</span>, <em>space_sigma=1</em><span class="optional">[</span>, <em>threshold=False</em><span class="optional">[</span>, <em>offset=0</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.bilateral" title="永久链接至目标">¶</a></dt>
<dd><p>通过双边滤波器对图像进行卷积。 双边滤波器使图像平滑，同时保持图像中的边缘。</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> 是内核的大小。取1 (3x3 内核)、2 (5x5 内核)或更高值。</p>
<p><code class="docutils literal notranslate"><span class="pre">color_sigma</span></code> 控制使用双边滤波器匹配颜色的接近程度。增加此值可增加颜色模糊。</p>
<p><code class="docutils literal notranslate"><span class="pre">space_sigma</span></code> 控制像素在空间方面相互模糊的程度。增加此值可增加像素模糊。</p>
<p>如果你想在滤波器的输出上自适应地设置阈值，你可以传递 <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> 参数来启动图像的自适应阈值处理，
他根据环境像素的亮度（核函数周围的像素的亮度有关），将像素设置为1或者0。
负数 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 值将更多像素设置为1，而正值仅将最强对比度设置为1。
设置 <code class="docutils literal notranslate"><span class="pre">invert</span></code> 以反转二进制图像的结果输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.cartoon">
<code class="descclassname">image.</code><code class="descname">cartoon</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>seed_threshold=0.05</em><span class="optional">[</span>, <em>floating_threshold=0.05</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.cartoon" title="永久链接至目标">¶</a></dt>
<dd><p>漫游图像并使用flood-fills算法填充图像中的所有像素区域。
这通过使图像的所有区域中的颜色变平来有效地从图像中去除纹理。
为了获得最佳效果，图像应具有大量对比度，以使区域不会太容易相互渗透。</p>
<p><code class="docutils literal notranslate"><span class="pre">seed_threshold</span></code> 控制填充区域中的像素与原始起始像素的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">floating_threshold</span></code> 控制填充区域中的像素与任何相邻像素的差异。</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> 是另一个用作绘图操作的像素级掩码的图像。掩码应该是一个只有黑色或白色像素的图像，并且应该与你正在绘制的 <code class="docutils literal notranslate"><span class="pre">image</span></code> 大小相同。
仅掩码中设置的像素被修改。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.remove_shadows">
<code class="descclassname">image.</code><code class="descname">remove_shadows</code><span class="sig-paren">(</span><span class="optional">[</span><em>image</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.remove_shadows" title="永久链接至目标">¶</a></dt>
<dd><p>从该图像中移除阴影。</p>
<p>如果当前图像没有“无阴影”版本出现，则此方法将尝试从图像中去除阴影，但没有真实无阴影的图像依据。 这种算法适用于去除平坦均匀背景中的阴影。
请注意，此方法需要多秒才能运行，并且仅适用于实时移除阴影，动态生成无阴影版本的图像。 该算法的未来版本将适用于更多的环境，但同样缓慢。</p>
<p>如果当前图像有“无阴影”版本出现，则此方法将使用“真实源”背景无阴影图像去除图像中的所有阴影以滤除阴影。
非阴影像素不会被过滤掉，因此您可以向场景中添加以前不存在的新对象，并且这些对象中的任何非阴影像素都将显示出来。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>只支持RGB565图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.chrominvar">
<code class="descclassname">image.</code><code class="descname">chrominvar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.chrominvar" title="永久链接至目标">¶</a></dt>
<dd><p>从图像中删除照明效果，仅留下颜色渐变。比 <a class="reference internal" href="#image.illuminvar" title="image.illuminvar"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.illuminvar()</span></code></a> 更快但受阴影影响。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>仅支持RGB565图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.illuminvar">
<code class="descclassname">image.</code><code class="descname">illuminvar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.illuminvar" title="永久链接至目标">¶</a></dt>
<dd><p>从图像中删除照明效果，仅留下颜色渐变。比 <a class="reference internal" href="#image.chrominvar" title="image.chrominvar"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.chrominvar()</span></code></a> 慢但不受阴影影响。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>仅支持RGB565图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.linpolar">
<code class="descclassname">image.</code><code class="descname">linpolar</code><span class="sig-paren">(</span><span class="optional">[</span><em>reverse=False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.linpolar" title="永久链接至目标">¶</a></dt>
<dd><p>图像从笛卡尔坐标到线性极坐标重新投影。</p>
<p>设置 <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">=</span> <span class="pre">True</span></code> 可以在相反的方向重新投影。</p>
<p>线性极坐标重新投影将图像旋转转换为x平移。</p>
<p>不支持压缩图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.logpolar">
<code class="descclassname">image.</code><code class="descname">logpolar</code><span class="sig-paren">(</span><span class="optional">[</span><em>reverse=False</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.logpolar" title="永久链接至目标">¶</a></dt>
<dd><p>图像从笛卡尔坐标到对数极坐标重新投影。</p>
<p>设置 <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">=</span> <span class="pre">True</span></code> 可以在相反的方向重新投影。</p>
<p>对数极坐标重新投影将图像的旋转转换为x平移和缩放到y平移。</p>
<p>不支持压缩图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.lens_corr">
<code class="descclassname">image.</code><code class="descname">lens_corr</code><span class="sig-paren">(</span><span class="optional">[</span><em>strength=1.8</em><span class="optional">[</span>, <em>zoom=1.0</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.lens_corr" title="永久链接至目标">¶</a></dt>
<dd><p>进行镜头畸变校正，以去除镜头造成的图像鱼眼效果。</p>
<p><code class="docutils literal notranslate"><span class="pre">strength</span></code>&nbsp;是一个浮点数，该值确定了对图像进行去鱼眼效果的程度。在默认情况下，首先试用取值1.8，然后调整这一数值使图像显示最佳效果。</p>
<p><code class="docutils literal notranslate"><span class="pre">zoom</span></code>&nbsp;是在对图像进行缩放的数值。默认值为 1.0 。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="img.rotation_corr">
<code class="descclassname">img.</code><code class="descname">rotation_corr</code><span class="sig-paren">(</span><span class="optional">[</span><em>x_rotation=0.0</em><span class="optional">[</span>, <em>y_rotation=0.0</em><span class="optional">[</span>, <em>z_rotation=0.0</em><span class="optional">[</span>, <em>x_translation=0.0</em><span class="optional">[</span>, <em>y_translation=0.0</em><span class="optional">[</span>, <em>zoom=1.0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#img.rotation_corr" title="永久链接至目标">¶</a></dt>
<dd><p>通过执行帧缓冲区的3D旋转来纠正图像中的透视问题。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_rotation</span></code> 是围绕x轴在帧缓冲器中旋转图像的度数（这使图像上下旋转）。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_rotation</span></code> 是帧缓冲区中围绕y轴旋转图像的度数（即左右旋转图像）。</p>
<p><code class="docutils literal notranslate"><span class="pre">z_rotation</span></code> 是围绕z轴在帧缓冲器中旋转图像的度数（即，使图像旋转到适当位置）。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_translation</span></code> 是旋转后将图像移动到左侧或右侧的单位数。因为这个变换是应用在三维空间的，单位不是像素…</p>
<p><code class="docutils literal notranslate"><span class="pre">y_translation</span></code> 是旋转后将图像上移或下移的单位数。因为这个变换是应用在三维空间的，单位不是像素…</p>
<p><code class="docutils literal notranslate"><span class="pre">zoom</span></code> 是通过图像缩放的量。默认情况下1.0。</p>
<p>返回图像对象，以便您可以使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示法调用另一个方法。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.get_similarity">
<code class="descclassname">image.</code><code class="descname">get_similarity</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="headerlink" href="#image.get_similarity" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个“相似度”对象，描述两幅图像使用SSIM算法来比较两幅图像之间的8x8像素色块的相似度。</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> 可以是图像对象，未压缩图像文件的路径(bmp/pgm/ppm)，也可以是标量值。
如果标量值，该值可以是RGB888元组或基础像素值(例如，灰度图像的8位灰度级或RGB图像的字节反转RGB565值)。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.get_histogram">
<code class="descclassname">image.</code><code class="descname">get_histogram</code><span class="sig-paren">(</span><span class="optional">[</span><em>thresholds</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>bins</em><span class="optional">[</span>, <em>l_bins</em><span class="optional">[</span>, <em>a_bins</em><span class="optional">[</span>, <em>b_bins</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.get_histogram" title="永久链接至目标">¶</a></dt>
<dd><p>在 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 的所有颜色通道上进行标准化直方图运算，并返回 <code class="docutils literal notranslate"><span class="pre">histogram</span></code> 对象。
请参考 <code class="docutils literal notranslate"><span class="pre">histogram</span></code> 对象以获取更多信息。您也可以使用 <code class="docutils literal notranslate"><span class="pre">image.get_hist</span></code> 或
<code class="docutils literal notranslate"><span class="pre">image.histogram</span></code> 来调用这一方法。如果传递 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 列表，则直方图信息将仅从阈值列表中的像素计算得出。</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 必须是元组列表。
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> 定义你想追踪的颜色范围。
对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。
对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。
为方便使用，此功能将自动修复交换的最小值和最大值。
此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。
直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。
这些将是 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 的低值和高值。
由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
<p class="last">您还可以通过进入OpenMV IDE中的 <code class="docutils literal notranslate"><span class="pre">工具</span> <span class="pre">-&gt;机器视觉</span> <span class="pre">-&gt;阈值编辑器</span></code> 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</p>
<p>除非您需要使用颜色统计信息进行高级操作，否则只需使用`image.get_statistics()` 方法代替此方法查看图像中的像素区域。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">bins</span></code> 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 <code class="docutils literal notranslate"><span class="pre">bins</span></code> ，
对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。
另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.get_statistics">
<code class="descclassname">image.</code><code class="descname">get_statistics</code><span class="sig-paren">(</span><span class="optional">[</span><em>thresholds</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>bins</em><span class="optional">[</span>, <em>l_bins</em><span class="optional">[</span>, <em>a_bins</em><span class="optional">[</span>, <em>b_bins</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.get_statistics" title="永久链接至目标">¶</a></dt>
<dd><p>计算 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。
请参见 <code class="docutils literal notranslate"><span class="pre">statistics</span></code> 对象以获取更多信息。您也可以使用 <code class="docutils literal notranslate"><span class="pre">image.get_stats</span></code> 或 <code class="docutils literal notranslate"><span class="pre">image.statistics</span></code> 来调用这一方法。
如果传递 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 列表，则直方图信息将仅从阈值列表中的像素计算得出。</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 必须是元组列表。
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> 定义你想追踪的颜色范围。
对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。
对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。
为方便使用，此功能将自动修复交换的最小值和最大值。
此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。
直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。
这些将是 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 的低值和高值。
由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
<p class="last">您还可以通过进入OpenMV IDE中的 <code class="docutils literal notranslate"><span class="pre">工具</span> <span class="pre">-&gt;机器视觉</span> <span class="pre">-&gt;阈值编辑器</span></code> 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</p>
<p>您可以在需要获取图像中一个像素区域信息时使用这一方法。例如：若您想用帧差法来检测运动时，
您需要使用这一方法来确定图像颜色通道的变化，从而触发运动检测阈值。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">bins</span></code> 和其他bin是用于直方图通道的箱数。对于灰度图像，使用 <code class="docutils literal notranslate"><span class="pre">bins</span></code> ，
对于RGB565图像，使用其他每个通道。每个通道的bin计数必须大于2。
另外，将bin计数设置为大于每个通道的唯一像素值的数量是没有意义的。 默认情况下，直方图将具有每个通道的最大bin数。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.get_regression">
<code class="descclassname">image.</code><code class="descname">get_regression</code><span class="sig-paren">(</span><em>thresholds</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>x_stride=2</em><span class="optional">[</span>, <em>y_stride=1</em><span class="optional">[</span>, <em>area_threshold=10</em><span class="optional">[</span>, <em>pixels_threshold=10</em><span class="optional">[</span>, <em>robust=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.get_regression" title="永久链接至目标">¶</a></dt>
<dd><p>对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。
若 <code class="docutils literal notranslate"><span class="pre">robust</span></code> 为True，则使用Theil-Sen线性回归算法，它计算图像中所有阈值像素的斜率的中位数。
若在阈值处理后有太多像素，即使在80x60的图像上，这个O(N^2)操作也可能将您的FPS降到5帧以下。
但是，只要阈值转换后的像素数量较少，即使在高达30％的阈值像素是异常值的情况下也依然有效，鲁棒性好。</p>
<p>这一方法返回的是一个 <a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a> 对象。如何轻松运用直线对象，
详见下博文： <a class="reference external" href="https://openmv.io/blogs/news/linear-regression-line-following">https://openmv.io/blogs/news/linear-regression-line-following</a></p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 必须是元组列表。
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> 定义你想追踪的颜色范围。
对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。
对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。
为方便使用，此功能将自动修复交换的最小值和最大值。
此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。
直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。
这些将是 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 的低值和高值。
由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
<p class="last">您还可以通过进入OpenMV IDE中的 <code class="docutils literal notranslate"><span class="pre">工具</span> <span class="pre">-&gt;机器视觉</span> <span class="pre">-&gt;阈值编辑器</span></code> 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 是调用函数时要跳过的x像素数。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 是调用函数时要跳过的y像素数。</p>
<p>如果回归后的边界框区域小于 <code class="docutils literal notranslate"><span class="pre">area_threshold</span></code> ，则返回None。</p>
<p>如果回归后的像素数小于 <code class="docutils literal notranslate"><span class="pre">pixel_threshold</span></code> ，则返回None。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_blobs">
<code class="descclassname">image.</code><code class="descname">find_blobs</code><span class="sig-paren">(</span><em>thresholds</em><span class="optional">[</span>, <em>invert=False</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>x_stride=2</em><span class="optional">[</span>, <em>y_stride=1</em><span class="optional">[</span>, <em>area_threshold=10</em><span class="optional">[</span>, <em>pixels_threshold=10</em><span class="optional">[</span>, <em>merge=False</em><span class="optional">[</span>, <em>margin=0</em><span class="optional">[</span>, <em>threshold_cb=None</em><span class="optional">[</span>, <em>merge_cb=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_blobs" title="永久链接至目标">¶</a></dt>
<dd><p>查找图像中所有色块，并返回一个包括每个色块的色块对象的列表。请观察 <code class="docutils literal notranslate"><span class="pre">image.blob</span></code> 对象以获取更多信息。</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 必须是元组列表。
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> 定义你想追踪的颜色范围。
对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。
对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。
为方便使用，此功能将自动修复交换的最小值和最大值。
此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。
直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。
这些将是 <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> 的低值和高值。
由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
<p class="last">您还可以通过进入OpenMV IDE中的 <code class="docutils literal notranslate"><span class="pre">工具</span> <span class="pre">-&gt;机器视觉</span> <span class="pre">-&gt;阈值编辑器</span></code> 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 是查找某色块时需要跳过的x像素的数量。找到色块后，直线填充算法将精确像素。
若已知色块较大，可增加 <code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 来提高查找色块的速度。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 是查找某色块时需要跳过的y像素的数量。找到色块后，直线填充算法将精确像素。
若已知色块较大，可增加 <code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 来提高查找色块的速度。</p>
<p>若一个色块的边界框区域小于 <code class="docutils literal notranslate"><span class="pre">area_threshold</span></code> ，则会被过滤掉。</p>
<p>若一个色块的像素数小于 <code class="docutils literal notranslate"><span class="pre">pixel_threshold</span></code> ，则会被过滤掉。</p>
<p><code class="docutils literal notranslate"><span class="pre">merge</span></code> 若为True，则合并所有没有被过滤掉的色块，这些色块的边界矩形互相交错重叠。
<code class="docutils literal notranslate"><span class="pre">margin</span></code> 可在相交测试中用来增大或减小色块边界矩形的大小。例如：边缘为1、相互间边界矩形为1的色块将被合并。</p>
<p>合并色块使颜色代码追踪得以实现。每个色块对象有一个代码值 <code class="docutils literal notranslate"><span class="pre">code</span></code> ，该值为一个位向量。
例如：若您在 <a class="reference internal" href="#image.find_blobs" title="image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_blobs</span></code></a> 中输入两个颜色阈值，则第一个阈值代码为1，第二个代码为2（第三个代码为4，第四个代码为8，以此类推）。
合并色块对所有的code使用逻辑或运算，以便您知道产生它们的颜色。这使得您可以追踪两个颜色，若您用两种颜色得到一个色块对象，则可能是一种颜色代码。</p>
<p>若您使用严格的颜色范围，无法完全追踪目标对象的所有像素，您可能需要合并色块。</p>
<p>最后，若您想要合并色块，但不想两种不同阈值颜色的色块被合并，只需分别两次调用 <code class="docutils literal notranslate"><span class="pre">image.find_blobs</span></code> ，不同阈值色块就不会被合并。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold_cb</span></code> 可设置为用以调用阈值筛选后的每个色块的函数，以便将其从将要合并的色块列表中过滤出来。
回调函数将收到一个参数：要被筛选的色块对象。然后回调函数需返回True以保留色块或返回False以过滤色块。</p>
<p><code class="docutils literal notranslate"><span class="pre">merge_cb</span></code> 可设置为用以调用两个即将合并的色块的函数，以禁止或准许合并。回调函数将收到两个参数—两个将被合并的色块对象。
回调函数须返回True以合并色块，或返回False以防止色块合并。</p>
<p>不支持压缩图像和bayer图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_lines">
<code class="descclassname">image.</code><code class="descname">find_lines</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>x_stride=2</em><span class="optional">[</span>, <em>y_stride=1</em><span class="optional">[</span>, <em>threshold=1000</em><span class="optional">[</span>, <em>theta_margin=25</em><span class="optional">[</span>, <em>rho_margin=25</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_lines" title="永久链接至目标">¶</a></dt>
<dd><p>使用霍夫变换查找图像中的所有直线。返回一个 <a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a> 对象的列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 是霍夫变换时需要跳过的x像素的数量。若已知直线较大，可增加 <code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 是霍夫变换时需要跳过的y像素的数量。若已知直线较大，可增加 <code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 控制从霍夫变换中监测到的直线。只返回大于或等于 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 的直线。
应用程序的正确的 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 值取决于图像。注意：一条直线的模(magnitude)是组成直线所有sobel滤波像素大小的总和。</p>
<p><code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> 控制所监测的直线的合并。
直线角度为 <code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> 的部分和直线p值为 <code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> 的部分合并。</p>
<p><code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> 控制所监测的直线的合并。
直线角度为 <code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> 的部分和直线p值为 <code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> 的部分合并。</p>
<p>该方法通过在图像上运行索贝尔滤波器，并利用该滤波器的幅值和梯度响应来进行霍夫变换。
无需对图像进行任何预处理。但是，清理图像过滤器可得到更为稳定的结果。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_line_segments">
<code class="descclassname">image.</code><code class="descname">find_line_segments</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>merge_distance=0</em><span class="optional">[</span>, <em>max_theta_difference=15</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_line_segments" title="永久链接至目标">¶</a></dt>
<dd><p>使用霍夫转换来查找图像中的线段。返回一个&nbsp;<a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a>&nbsp;对象的列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， <code class="docutils literal notranslate"><span class="pre">ROI</span></code> 即图像矩形。操作范围仅限于roi区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">merge_distance</span></code> 指定两条线段之间的可以相互分开而不被合并的最大像素数。</p>
<p><code class="docutils literal notranslate"><span class="pre">max_theta_difference</span></code> 是上面 <code class="docutils literal notranslate"><span class="pre">merge_distancede</span></code> 要合并的的两个线段的最大角度差值。</p>
<p>此方法使用LSD库（也被OpenCV使用）来查找图像中的线段。这有点慢，但是非常准确，线段不会跳跃。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_circles">
<code class="descclassname">image.</code><code class="descname">find_circles</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>x_stride=2</em><span class="optional">[</span>, <em>y_stride=1</em><span class="optional">[</span>, <em>threshold=2000</em><span class="optional">[</span>, <em>x_margin=10</em><span class="optional">[</span>, <em>y_margin=10</em><span class="optional">[</span>, <em>r_margin=10</em><span class="optional">[</span>, <em>r_min=2</em><span class="optional">[</span>, <em>r_max</em><span class="optional">[</span>, <em>r_step=2</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_circles" title="永久链接至目标">¶</a></dt>
<dd><p>使用霍夫变换在图像中查找圆。返回一个 <a class="reference internal" href="#image.circle" title="image.circle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.circle</span></code></a> 对象列表（见上）。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定， <code class="docutils literal notranslate"><span class="pre">ROI</span></code> 即图像矩形。操作范围仅限于roi区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 是霍夫变换时需要跳过的x像素的数量。若已知圆较大，可增加 <code class="docutils literal notranslate"><span class="pre">x_stride</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 是霍夫变换时需要跳过的y像素的数量。若已知圆较大，可增加 <code class="docutils literal notranslate"><span class="pre">y_stride</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 控制从霍夫变换中监测到的圆。只返回大于或等于 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 的圆。
应用程序的正确的 <code class="docutils literal notranslate"><span class="pre">threshold</span></code> 值取决于图像。注意：一个圆的大小(magnitude)是组成圆所有索贝尔滤波像素大小的总和。</p>
<p><code class="docutils literal notranslate"><span class="pre">x_margin</span></code> 控制所检测的圆的合并。&nbsp;圆像素为 <code class="docutils literal notranslate"><span class="pre">x_margin</span></code> 、 <code class="docutils literal notranslate"><span class="pre">y_margin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r_margin</span></code>&nbsp;的部分合并。</p>
<p><code class="docutils literal notranslate"><span class="pre">y_margin</span></code> 控制所检测的圆的合并。&nbsp;圆像素为 <code class="docutils literal notranslate"><span class="pre">x_margin</span></code> 、 <code class="docutils literal notranslate"><span class="pre">y_margin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r_margin</span></code>&nbsp;的部分合并。</p>
<p><code class="docutils literal notranslate"><span class="pre">r_margin</span></code> 控制所检测的圆的合并。&nbsp;圆像素为 <code class="docutils literal notranslate"><span class="pre">x_margin</span></code> 、 <code class="docutils literal notranslate"><span class="pre">y_margin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">r_margin</span></code>&nbsp;的部分合并。</p>
<p><code class="docutils literal notranslate"><span class="pre">r_min</span></code> 控制检测到的最小圆半径。增加此值可以加速算法。默认为2。</p>
<p><a href="#id49"><span class="problematic" id="id50">``</span></a>r_max``控制检测到的最大圆半径。减少此值可以加快算法。默认为 min(roi.w/2, roi.h/2)。</p>
<p><code class="docutils literal notranslate"><span class="pre">r_step</span></code> 控制如何逐步检测半径。默认为2。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_rects">
<code class="descclassname">image.</code><code class="descname">find_rects</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi=Auto</em>, <em>threshold=10000</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_rects" title="永久链接至目标">¶</a></dt>
<dd><p>使用用于查找AprilTAg的相同的quad detection算法来查找图像中的矩形。
最适用与背景形成鲜明对比的矩形。AprilTag的quad detection可以处理任意缩放/旋转/剪切的矩形。
返回一个 <a class="reference internal" href="#image.rect" title="image.rect"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.rect</span></code></a> 对象的列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code>&nbsp;是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，
ROI即图像矩形。操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>边界大小（通过在矩形边缘上的所有像素上滑动索贝尔算子并相加该值）小于&nbsp;<code class="docutils literal notranslate"><span class="pre">threshold</span></code> 的矩形会从返回列表中过滤出来。
<code class="docutils literal notranslate"><span class="pre">threshold</span></code> 的正确值取决于您的应用程序/场景。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_qrcodes">
<code class="descclassname">image.</code><code class="descname">find_qrcodes</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_qrcodes" title="永久链接至目标">¶</a></dt>
<dd><p>查找 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 内的所有二维码并返回一个 <a class="reference internal" href="#image.qrcode" title="image.qrcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.qrcode</span></code></a> 对象的列表。
请参考 <a class="reference internal" href="#image.qrcode" title="image.qrcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.qrcode</span></code></a> 对象以获取更多信息。</p>
<p>为使这一方法成功运行，图像上二维码需比较平展。通过使用 <code class="docutils literal notranslate"><span class="pre">sensor.set_windowing</span></code>&nbsp;函数在镜头中心放大、
<code class="docutils literal notranslate"><span class="pre">image.lens_corr</span></code>&nbsp;函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头，
您可得到一个不受镜头畸变影响的更为平展的二维码。有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头为无畸变镜头。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code>&nbsp;是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_apriltags">
<code class="descclassname">image.</code><code class="descname">find_apriltags</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>families=image.TAG36H11</em><span class="optional">[</span>, <em>fx</em><span class="optional">[</span>, <em>fy</em><span class="optional">[</span>, <em>cx</em><span class="optional">[</span>, <em>cy</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_apriltags" title="永久链接至目标">¶</a></dt>
<dd><p>查找 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 内的所有AprilTag, 并返回一个 <a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a> 对象的列表。请参考&nbsp;<a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a> 对象以获取更多信息。</p>
<p>与二维码相比，AprilTags可在更远距离、较差光线和更扭曲的图像环境下被检测到。
AprilTags可应对所有种类的图像失真问题，而二维码并不能。也就是说，AprilTags只能将数字ID编码作为其有效载荷。</p>
<p>AprilTags也可用于本地化。每个 <a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a> 对象都从摄像机返回其三维位置信息和旋转角度。
位置信息由 <code class="docutils literal notranslate"><span class="pre">fx</span></code> 、 <code class="docutils literal notranslate"><span class="pre">fy</span></code> 、 <code class="docutils literal notranslate"><span class="pre">cx</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cy</span></code> 决定，分别为X和Y方向上图像的焦距和中心点。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">使用OpenMV IDE内置的标签生成器工具来创建AprilTags。标签生成器可创建可打印的8.5“x11”AprilTags。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code>&nbsp;是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">families</span></code> 是要解码的标签家族的位掩码。是一个逻辑或：</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#image.TAG16H5" title="image.TAG16H5"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG16H5</span></code></a></li>
<li><a class="reference internal" href="#image.TAG25H7" title="image.TAG25H7"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG25H7</span></code></a></li>
<li><a class="reference internal" href="#image.TAG25H9" title="image.TAG25H9"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG25H9</span></code></a></li>
<li><a class="reference internal" href="#image.TAG36H10" title="image.TAG36H10"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H10</span></code></a></li>
<li><a class="reference internal" href="#image.TAG36H11" title="image.TAG36H11"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H11</span></code></a></li>
<li><a class="reference internal" href="#image.ARTOOLKIT" title="image.ARTOOLKIT"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ARTOOLKIT</span></code></a></li>
</ul>
</div></blockquote>
<p>默认设置为最好用的&nbsp;<a class="reference internal" href="#image.TAG36H11" title="image.TAG36H11"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H11</span></code></a> 标签家族。注意：每启用一个标签家族， <a class="reference internal" href="#image.find_apriltags" title="image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">find_apriltags</span></code></a> 的速度都会略有放慢。</p>
<p><code class="docutils literal notranslate"><span class="pre">fx</span></code> 是以像素为单位的相机x方向的焦距。标准OpenMV Cam的值为(2.8 / 3.984) * 656，
该值通过毫米计的焦距值除以X方向上感光元件的长度，再乘以X方向上感光元件的像素数量得来（对OV7725感光元件而言）。</p>
<p><code class="docutils literal notranslate"><span class="pre">fy</span></code> 是以像素为单位的相机y方向的焦距。标准OpenMV Cam的值为(2.8 / 2.952) * 488，
该值通过毫米计的焦距值除以Y方向上感光元件的长度，再乘以Y方向上感光元件的像素数量得来（对OV7725感光元件而言）。</p>
<p><code class="docutils literal notranslate"><span class="pre">cx</span></code> 是图像的中心，即 <code class="docutils literal notranslate"><span class="pre">image.width()/2</span></code> ，而非 <code class="docutils literal notranslate"><span class="pre">roi.w()/2</span></code> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">cy</span></code> 是图像的中心，即 <code class="docutils literal notranslate"><span class="pre">image.height()/2</span></code>，而非 <code class="docutils literal notranslate"><span class="pre">roi.h()/2</span></code> 。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_datamatrices">
<code class="descclassname">image.</code><code class="descname">find_datamatrices</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>effort=200</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_datamatrices" title="永久链接至目标">¶</a></dt>
<dd><p>查找 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 内的所有数据矩阵并返回一个 <a class="reference internal" href="#image.datamatrix" title="image.datamatrix"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.datamatrix</span></code></a> 对象的列表。
请参考&nbsp;<a class="reference internal" href="#image.datamatrix" title="image.datamatrix"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.datamatrix</span></code></a> 对象以获取更多信息。</p>
<p>为使这一方法成功运行，图像上矩形码需比较平展。通过使用 <a class="reference internal" href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html#sensor.sensor.set_windowing" title="sensor.sensor.set_windowing"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sensor.set_windowing</span></code></a>&nbsp;函数在镜头中心放大、
<a class="reference internal" href="#image.lens_corr" title="image.lens_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.lens_corr</span></code></a>&nbsp;函数来消解镜头的桶形畸变或通过更换视野较为狭小的镜头，您可得到一个不受镜头畸变影响的更为平展的矩形码。
有些机器视觉镜头不会造成桶形失真，但是其造价远比OpenMV提供的标准镜片高，这种镜头是无畸变镜头。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">effort</span></code> 控制用于查找矩形码匹配的时间。默认值为200应该适用于所有用例。
但是您也可能以帧速率为代价增加检测，或以检测为代价增加帧速率。
注意：若 <code class="docutils literal notranslate"><span class="pre">effort</span></code> 设置在约160以下，您就无法进行任何检测；相反，您可将其设置为您需要的任何高值，但是若设置值高于240，检测率将不会继续随之提高。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_barcodes">
<code class="descclassname">image.</code><code class="descname">find_barcodes</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_barcodes" title="永久链接至目标">¶</a></dt>
<dd><p>查找 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 内所有一维条形码并返回一个 <a class="reference internal" href="#image.barcode" title="image.barcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.barcode</span></code></a> 对象列表。
请参考&nbsp;<a class="reference internal" href="#image.barcode" title="image.barcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.barcode</span></code></a> 对象以获取更多信息。</p>
<p>为了获得最佳效果，请使用长640、宽40/80／160窗口。垂直程度越低，运行速度越快。由于条形码是线性一维图像，所以只需在一个方向上有较高分辨率，
而在另一方向上只需较低分辨率。注意：该函数进行水平和垂直扫描，所以您可使用宽40/80／160、长480的窗口。
最后，请一定调整镜头，这样条形码会定位在焦距产生最清晰图像的地方。模糊条码无法被解码。</p>
<p>该函数支持所有一维条形码：</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#image.EAN2" title="image.EAN2"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN2</span></code></a></li>
<li><a class="reference internal" href="#image.EAN5" title="image.EAN5"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN5</span></code></a></li>
<li><a class="reference internal" href="#image.EAN8" title="image.EAN8"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN8</span></code></a></li>
<li><a class="reference internal" href="#image.UPCE" title="image.UPCE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.UPCE</span></code></a></li>
<li><a class="reference internal" href="#image.ISBN10" title="image.ISBN10"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ISBN10</span></code></a></li>
<li><a class="reference internal" href="#image.UPCA" title="image.UPCA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.UPCA</span></code></a></li>
<li><a class="reference internal" href="#image.EAN13" title="image.EAN13"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN13</span></code></a></li>
<li><a class="reference internal" href="#image.ISBN13" title="image.ISBN13"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ISBN13</span></code></a></li>
<li><a class="reference internal" href="#image.I25" title="image.I25"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.I25</span></code></a></li>
<li><a class="reference internal" href="#image.DATABAR" title="image.DATABAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.DATABAR</span></code></a> (RSS-14)</li>
<li><a class="reference internal" href="#image.DATABAR_EXP" title="image.DATABAR_EXP"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.DATABAR_EXP</span></code></a> (RSS-Expanded)</li>
<li><a class="reference internal" href="#image.CODABAR" title="image.CODABAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODABAR</span></code></a></li>
<li><a class="reference internal" href="#image.CODE39" title="image.CODE39"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE39</span></code></a></li>
<li><a class="reference internal" href="#image.PDF417" title="image.PDF417"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.PDF417</span></code></a></li>
<li><a class="reference internal" href="#image.CODE93" title="image.CODE93"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE93</span></code></a></li>
<li><a class="reference internal" href="#image.CODE128" title="image.CODE128"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE128</span></code></a></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是一个用以复制的矩形的感兴趣区域(x, y, w, h)。如果未指定，ROI即整幅图像的图像矩形。操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>不支持压缩图像和bayer图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_displacement">
<code class="descclassname">image.</code><code class="descname">find_displacement</code><span class="sig-paren">(</span><em>template</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>template_roi</em><span class="optional">[</span>, <em>logpolar=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_displacement" title="永久链接至目标">¶</a></dt>
<dd><p>从模板中查找此图像的变换偏移量。 这种方法可以用来做光流。 此方法返回一个 <a class="reference internal" href="#image.displacement" title="image.displacement"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.displacement</span></code></a> 对象，其中包含使用相位相关的位移计算结果。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。</p>
<p><code class="docutils literal notranslate"><span class="pre">template_roi</span></code> 是需要处理的矩形区域（x，y，w，h）。如果未指定，则等于图像矩形。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 和 <code class="docutils literal notranslate"><span class="pre">template</span></code> roi必须具有相同的w/h，但x/y可以为图像任意位置。您可以在较大图像上滑动较小的rois以获得光流渐变图像.</p>
<p><code class="docutils literal notranslate"><span class="pre">image.find_displacement</span></code> 通常计算两个图像之间的x/y平移。但是，如果您设置 <code class="docutils literal notranslate"><span class="pre">logpolar</span> <span class="pre">=</span> <span class="pre">True</span></code> ，
它将会在两个图像之间找到旋转和缩放比例的变化。相同的 <a class="reference internal" href="#image.displacement" title="image.displacement"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.displacement</span></code></a> 对象结果两种可能的反馈。</p>
<p>不支持压缩图像和bayer图像。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<blockquote>
<div>请在长宽一致的图像（例如``sensor.B64X64``）上使用此方法。</div></blockquote>
<p class="last">不支持压缩图像和bayer图像。</p>
</div>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_template">
<code class="descclassname">image.</code><code class="descname">find_template</code><span class="sig-paren">(</span><em>template</em>, <em>threshold</em><span class="optional">[</span>, <em>roi</em><span class="optional">[</span>, <em>step=2</em><span class="optional">[</span>, <em>search=image.SEARCH_EX</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_template" title="永久链接至目标">¶</a></dt>
<dd><p>尝试使用归一化互相关(NCC)算法在图像中找到第一个模板匹配的位置。返回匹配位置的边界框元组(x, y, w, h)，否则返回None。</p>
<p><code class="docutils literal notranslate"><span class="pre">template</span></code> 是一个与这个图像对象相匹配的小图像对象。注意：两图像须都为灰度图。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">step</span></code> 是查找模板时需要跳过的像素数量。跳过像素可大大提高算法运行的速度。该方法只适用于SERACH_EX模式下的算法。</p>
<p><code class="docutils literal notranslate"><span class="pre">search</span></code> 可为 <code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code> or <code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code>.
<code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code> 搜索模板所用算法较 <code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code> 更快，但若模板位于图像边缘周围，可能无法成功搜索。
<code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code>&nbsp;可对图像进行较为详尽的搜索，但其运行速度远低于 <code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code> 。</p>
<p>仅支持灰度图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_features">
<code class="descclassname">image.</code><code class="descname">find_features</code><span class="sig-paren">(</span><em>cascade</em><span class="optional">[</span>, <em>threshold=0.5</em><span class="optional">[</span>, <em>scale=1.5</em><span class="optional">[</span>, <em>roi</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_features" title="永久链接至目标">¶</a></dt>
<dd><p>这个方法搜索与Haar Cascade匹配的所有区域的图像，并返回一个关于这些特征的边界框矩形元组(x，y，w，h)的列表。若未发现任何特征，则返回一个空白列表。</p>
<p><code class="docutils literal notranslate"><span class="pre">cascade</span></code> 是一个Haar Cascade对象。详细信息请查看 <a class="reference internal" href="#image.HaarCascade" title="image.HaarCascade"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.HaarCascade()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 是浮点数（0.0-1.0），其中较小的值在提高检测速率同时增加误报率。相反，较高的值会降低检测速率，同时降低误报率。</p>
<p><code class="docutils literal notranslate"><span class="pre">scale</span></code> 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_eye">
<code class="descclassname">image.</code><code class="descname">find_eye</code><span class="sig-paren">(</span><em>roi</em><span class="sig-paren">)</span><a class="headerlink" href="#image.find_eye" title="永久链接至目标">¶</a></dt>
<dd><p>在眼睛周围的感兴趣区域(x, y, w, h)查找瞳孔。返回一个包含图像中瞳孔(x，y)位置的元组。若未发现瞳孔，则返回(0,0)。</p>
<p>使用这一函数之前，需首先使用&nbsp;<a class="reference internal" href="#image.find_features" title="image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">image.find_features()</span></code></a> 和Haar算子 <code class="docutils literal notranslate"><span class="pre">frontalface</span></code>&nbsp;来搜索某人面部。
然后使用 <code class="docutils literal notranslate"><span class="pre">image.find_features</span></code> 和Haar算子 <code class="docutils literal notranslate"><span class="pre">find_eye</span></code> 在面部搜索眼睛。
最后，在调用 <code class="docutils literal notranslate"><span class="pre">image.find_features</span></code> 函数后返回的每个眼睛ROI上调用这一方法，以得到瞳孔的坐标。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>仅支持灰度图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_lbp">
<code class="descclassname">image.</code><code class="descname">find_lbp</code><span class="sig-paren">(</span><em>roi</em><span class="sig-paren">)</span><a class="headerlink" href="#image.find_lbp" title="永久链接至目标">¶</a></dt>
<dd><p>从ROI元组(x, y, w, h)中提取LBP（局部二值模式）键点。您可以使用 <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor</span></code></a> 函数来比较两组关键点，以获取匹配距离。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>仅支持灰度图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_keypoints">
<code class="descclassname">image.</code><code class="descname">find_keypoints</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>threshold=20</em><span class="optional">[</span>, <em>normalized=False</em><span class="optional">[</span>, <em>scale_factor=1.5</em><span class="optional">[</span>, <em>max_keypoints=100</em><span class="optional">[</span>, <em>corner_detector=image.CORNER_AGAST</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_keypoints" title="永久链接至目标">¶</a></dt>
<dd><p>从ROI元组(x, y, w, h)中提取ORB键点。您可以使用 <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor</span></code></a> 函数来比较两组关键点，以获取匹配区域。若未发现关键点，则返回None。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 是控制提取的数量的数字（取值0-255）。对于默认的AGAST角点检测器，该值应在20左右。
对于FAST角点检测器，该值约为60-80。阈值越低，您提取的角点越多。</p>
<p><code class="docutils literal notranslate"><span class="pre">normalized</span></code> 是布尔值。若为True，在多分辨率下关闭提取键点。
若您不关心处理扩展问题，且希望算法运行更快，就将之设置为True。</p>
<p><code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> 是一个必须大于1.0的浮点数。较高的比例因子运行更快，但其图像匹配相应较差。理想值介于1.35-1.5之间。</p>
<p><code class="docutils literal notranslate"><span class="pre">max_keypoints</span></code> 是一个键点对象所能容纳的键点最大数量。若键点对象过大导致内存问题，请降低该值。</p>
<p><code class="docutils literal notranslate"><span class="pre">corner_detector</span></code> 是从图像中提取键点所使用的角点检测器算法。
可为 <a class="reference internal" href="#image.CORNER_FAST" title="image.CORNER_FAST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CORNER_FAST</span></code></a> 或 <a class="reference internal" href="#image.CORNER_AGAST" title="image.CORNER_AGAST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CORNER_AGAST</span></code></a> 。FAST角点检测器运行速度更快，但其准确度较低。</p>
<p>仅支持灰度图像。</p>
</dd></dl>

<dl class="method">
<dt id="image.find_edges">
<code class="descclassname">image.</code><code class="descname">find_edges</code><span class="sig-paren">(</span><em>edge_type</em><span class="optional">[</span>, <em>threshold</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.find_edges" title="永久链接至目标">¶</a></dt>
<dd><p>将图像变为黑白，仅将边缘保留为白色像素。</p>
<blockquote>
<div><ul class="simple">
<li>image.EDGE_SIMPLE - 简单的阈值高通滤波算法</li>
<li>image.EDGE_CANNY - Canny边缘检测算法</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> 是一个包含一个低阈值和一个高阈值的二值元组。您可以通过调整该值来控制边缘质量。</p>
<p>默认为 (100, 200)。</p>
<p>仅支持灰度图像。</p>
</dd></dl>

<dl class="method">
<dt id="find_hog">
<code class="descname">find_hog</code><span class="sig-paren">(</span><span class="optional">[</span><em>roi</em><span class="optional">[</span>, <em>size=8</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#find_hog" title="永久链接至目标">¶</a></dt>
<dd><p>用HOG（定向梯度直方图）线替换ROI中的像素。</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。
操作范围仅限于 <code class="docutils literal notranslate"><span class="pre">roi</span></code> 区域内的像素。</p>
<p>仅支持灰度图像。</p>
<p>此方法在OpenMV Cam M4 上不可用。</p>
</dd></dl>

</div>
<div class="section" id="id51">
<h2>常量<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<dl class="data">
<dt id="image.SEARCH_EX">
<code class="descclassname">image.</code><code class="descname">SEARCH_EX</code><a class="headerlink" href="#image.SEARCH_EX" title="永久链接至目标">¶</a></dt>
<dd><p>详尽的模板匹配搜索。</p>
</dd></dl>

<dl class="data">
<dt id="image.SEARCH_DS">
<code class="descclassname">image.</code><code class="descname">SEARCH_DS</code><a class="headerlink" href="#image.SEARCH_DS" title="永久链接至目标">¶</a></dt>
<dd><p>更快的模板匹配搜索。</p>
</dd></dl>

<dl class="data">
<dt id="image.EDGE_CANNY">
<code class="descclassname">image.</code><code class="descname">EDGE_CANNY</code><a class="headerlink" href="#image.EDGE_CANNY" title="永久链接至目标">¶</a></dt>
<dd><p>使用Canny边缘检测算法对图像进行边缘检测。</p>
</dd></dl>

<dl class="data">
<dt id="image.EDGE_SIMPLE">
<code class="descclassname">image.</code><code class="descname">EDGE_SIMPLE</code><a class="headerlink" href="#image.EDGE_SIMPLE" title="永久链接至目标">¶</a></dt>
<dd><p>使用阈值高通滤波算法对图像进行边缘检测。</p>
</dd></dl>

<dl class="data">
<dt id="image.CORNER_FAST">
<code class="descclassname">image.</code><code class="descname">CORNER_FAST</code><a class="headerlink" href="#image.CORNER_FAST" title="永久链接至目标">¶</a></dt>
<dd><p>用于ORB键点的高速低准确率角点检测算法</p>
</dd></dl>

<dl class="data">
<dt id="image.CORNER_AGAST">
<code class="descclassname">image.</code><code class="descname">CORNER_AGAST</code><a class="headerlink" href="#image.CORNER_AGAST" title="永久链接至目标">¶</a></dt>
<dd><p>用于ORB键点的低速高准确率算法。</p>
</dd></dl>

<dl class="data">
<dt id="image.TAG16H5">
<code class="descclassname">image.</code><code class="descname">TAG16H5</code><a class="headerlink" href="#image.TAG16H5" title="永久链接至目标">¶</a></dt>
<dd><p>TAG1H5标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.TAG25H7">
<code class="descclassname">image.</code><code class="descname">TAG25H7</code><a class="headerlink" href="#image.TAG25H7" title="永久链接至目标">¶</a></dt>
<dd><p>TAG25H7标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.TAG25H9">
<code class="descclassname">image.</code><code class="descname">TAG25H9</code><a class="headerlink" href="#image.TAG25H9" title="永久链接至目标">¶</a></dt>
<dd><p>TAG25H9标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.TAG36H10">
<code class="descclassname">image.</code><code class="descname">TAG36H10</code><a class="headerlink" href="#image.TAG36H10" title="永久链接至目标">¶</a></dt>
<dd><p>TAG36H10标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.TAG36H11">
<code class="descclassname">image.</code><code class="descname">TAG36H11</code><a class="headerlink" href="#image.TAG36H11" title="永久链接至目标">¶</a></dt>
<dd><p>TAG36H11标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.ARTOOLKIT">
<code class="descclassname">image.</code><code class="descname">ARTOOLKIT</code><a class="headerlink" href="#image.ARTOOLKIT" title="永久链接至目标">¶</a></dt>
<dd><p>ARTOOLKIT标签群的位掩码枚举。用于AprilTags。</p>
</dd></dl>

<dl class="data">
<dt id="image.EAN2">
<code class="descclassname">image.</code><code class="descname">EAN2</code><a class="headerlink" href="#image.EAN2" title="永久链接至目标">¶</a></dt>
<dd><p>EAN2条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.EAN5">
<code class="descclassname">image.</code><code class="descname">EAN5</code><a class="headerlink" href="#image.EAN5" title="永久链接至目标">¶</a></dt>
<dd><p>EAN5条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.EAN8">
<code class="descclassname">image.</code><code class="descname">EAN8</code><a class="headerlink" href="#image.EAN8" title="永久链接至目标">¶</a></dt>
<dd><p>EAN8条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.UPCE">
<code class="descclassname">image.</code><code class="descname">UPCE</code><a class="headerlink" href="#image.UPCE" title="永久链接至目标">¶</a></dt>
<dd><p>UPCE条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.ISBN10">
<code class="descclassname">image.</code><code class="descname">ISBN10</code><a class="headerlink" href="#image.ISBN10" title="永久链接至目标">¶</a></dt>
<dd><p>ISBN10条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.UPCA">
<code class="descclassname">image.</code><code class="descname">UPCA</code><a class="headerlink" href="#image.UPCA" title="永久链接至目标">¶</a></dt>
<dd><p>UPCA条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.EAN13">
<code class="descclassname">image.</code><code class="descname">EAN13</code><a class="headerlink" href="#image.EAN13" title="永久链接至目标">¶</a></dt>
<dd><p>EAN13条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.ISBN13">
<code class="descclassname">image.</code><code class="descname">ISBN13</code><a class="headerlink" href="#image.ISBN13" title="永久链接至目标">¶</a></dt>
<dd><p>ISBN13条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.I25">
<code class="descclassname">image.</code><code class="descname">I25</code><a class="headerlink" href="#image.I25" title="永久链接至目标">¶</a></dt>
<dd><p>I25条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.DATABAR">
<code class="descclassname">image.</code><code class="descname">DATABAR</code><a class="headerlink" href="#image.DATABAR" title="永久链接至目标">¶</a></dt>
<dd><p>DATABAR条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.DATABAR_EXP">
<code class="descclassname">image.</code><code class="descname">DATABAR_EXP</code><a class="headerlink" href="#image.DATABAR_EXP" title="永久链接至目标">¶</a></dt>
<dd><p>DATABAR_EXP条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.CODABAR">
<code class="descclassname">image.</code><code class="descname">CODABAR</code><a class="headerlink" href="#image.CODABAR" title="永久链接至目标">¶</a></dt>
<dd><p>CODABAR条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.CODE39">
<code class="descclassname">image.</code><code class="descname">CODE39</code><a class="headerlink" href="#image.CODE39" title="永久链接至目标">¶</a></dt>
<dd><p>CODE39条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.PDF417">
<code class="descclassname">image.</code><code class="descname">PDF417</code><a class="headerlink" href="#image.PDF417" title="永久链接至目标">¶</a></dt>
<dd><p>PDF417条形码类型枚举（目前尚不能运行）。</p>
</dd></dl>

<dl class="data">
<dt id="image.CODE93">
<code class="descclassname">image.</code><code class="descname">CODE93</code><a class="headerlink" href="#image.CODE93" title="永久链接至目标">¶</a></dt>
<dd><p>CODE93条形码类型枚举。</p>
</dd></dl>

<dl class="data">
<dt id="image.CODE128">
<code class="descclassname">image.</code><code class="descname">CODE128</code><a class="headerlink" href="#image.CODE128" title="永久链接至目标">¶</a></dt>
<dd><p>CODE128条形码类型枚举。</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.nn.html" class="btn btn-neutral float-right" title="nn — 神经网络" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/omv.sensor.html" class="btn btn-neutral float-left" title="sensor — 感光元件" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr>

  <div role="contentinfo">
    <p>
        © Copyright 2014-2017, Damien P. George, Paul Sokolovsky, OpenMV LLC, 星瞳科技SingTown, and contributors
      <span class="lastupdated">
        最后更新于 16 3月 2020.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Ports and Versions</span>
    openmvcam (latest)
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Ports</dt>
      
        <dd><a href="https://docs.singtown.com/micropython/zh/latest/pyboard/index.html">pyboard</a></dd>
      
        <dd><a href="https://docs.singtown.com/micropython/zh/latest/moxingstm32f4/index.html">moxingstm32f4</a></dd>
      
        <dd><a href="https://docs.singtown.com/micropython/zh/latest/esp32/index.html">esp32</a></dd>
      
        <dd><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">openmvcam</a></dd>
      
    </dl>
    <dl>
      <dt>Versions</dt>
      
        <dd><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">latest</a></dd>
      
    </dl>
    <dl>
        <dt>Language</dt>
        
          <dd><a href="http://docs.openmv.io/">English</a></dd>
        
          <dd><a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">中文</a></dd>
        
    </dl>

    <dl>
    </dl>
    <hr>
    <dl>
      <dt>External links</dt>
        <dd>
          <a href="https://kaizhi-xu.taobao.com/">立即购买 OpenMV Cam</a>
        </dd>
    </dl>
  </div>
</div>


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   


</body></html>